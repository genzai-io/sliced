// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/store.proto

/*
	Package store is a generated protocol buffer package.

	It is generated from these files:
		proto/store.proto

	It has these top-level messages:
		App
		Worker
		Node
		RaftMember
		NodeGroup
		Database
		SliceID
		Slice
		SliceNode
		Rebalance
		Ring
		SlotRange
		Drive
		DriveStats
		Bucket
		RecordID
		Record
		Projection
		Index
		Topic
		Roller
		Path
		Hash
		Segment
		SegmentStats
		SegmentHeader
		GlobalID
		RecordPointer
		Queue
		Daemon
		InitNode
		AddNodeToGroup
		CreateDatabaseRequest
		CreateDatabaseReply
		TxCreateTopic
		TxCreateQueue
		TxCreateSegment
		TxRoll
		TxDeleteTopic
		TxChangeRing
		TxChangeRingCancel
		TxSplitTopic
*/
package store

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Level int32

const (
	Level_MISSION    Level = 0
	Level_BUSINESS   Level = 1
	Level_BACKGROUND Level = 2
)

var Level_name = map[int32]string{
	0: "MISSION",
	1: "BUSINESS",
	2: "BACKGROUND",
}
var Level_value = map[string]int32{
	"MISSION":    0,
	"BUSINESS":   1,
	"BACKGROUND": 2,
}

func (x Level) String() string {
	return proto.EnumName(Level_name, int32(x))
}
func (Level) EnumDescriptor() ([]byte, []int) { return fileDescriptorStore, []int{0} }

type Codec int32

const (
	Codec_JSON     Codec = 0
	Codec_PROTOBUF Codec = 1
	Codec_MSGPACK  Codec = 2
	Codec_CBOR     Codec = 3
)

var Codec_name = map[int32]string{
	0: "JSON",
	1: "PROTOBUF",
	2: "MSGPACK",
	3: "CBOR",
}
var Codec_value = map[string]int32{
	"JSON":     0,
	"PROTOBUF": 1,
	"MSGPACK":  2,
	"CBOR":     3,
}

func (x Codec) String() string {
	return proto.EnumName(Codec_name, int32(x))
}
func (Codec) EnumDescriptor() ([]byte, []int) { return fileDescriptorStore, []int{1} }

type Suffrage int32

const (
	Suffrage_VOTER     Suffrage = 0
	Suffrage_NON_VOTER Suffrage = 1
	Suffrage_STAGING   Suffrage = 2
)

var Suffrage_name = map[int32]string{
	0: "VOTER",
	1: "NON_VOTER",
	2: "STAGING",
}
var Suffrage_value = map[string]int32{
	"VOTER":     0,
	"NON_VOTER": 1,
	"STAGING":   2,
}

func (x Suffrage) String() string {
	return proto.EnumName(Suffrage_name, int32(x))
}
func (Suffrage) EnumDescriptor() ([]byte, []int) { return fileDescriptorStore, []int{2} }

type RaftStatus int32

const (
	RaftStatus_FOLLOWER  RaftStatus = 0
	RaftStatus_CANDIDATE RaftStatus = 1
	RaftStatus_LEADER    RaftStatus = 2
	RaftStatus_SHUTDOWN  RaftStatus = 3
)

var RaftStatus_name = map[int32]string{
	0: "FOLLOWER",
	1: "CANDIDATE",
	2: "LEADER",
	3: "SHUTDOWN",
}
var RaftStatus_value = map[string]int32{
	"FOLLOWER":  0,
	"CANDIDATE": 1,
	"LEADER":    2,
	"SHUTDOWN":  3,
}

func (x RaftStatus) String() string {
	return proto.EnumName(RaftStatus_name, int32(x))
}
func (RaftStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorStore, []int{3} }

type Drive_Kind int32

const (
	Drive_HDD  Drive_Kind = 0
	Drive_SSD  Drive_Kind = 1
	Drive_NVME Drive_Kind = 2
)

var Drive_Kind_name = map[int32]string{
	0: "HDD",
	1: "SSD",
	2: "NVME",
}
var Drive_Kind_value = map[string]int32{
	"HDD":  0,
	"SSD":  1,
	"NVME": 2,
}

func (x Drive_Kind) String() string {
	return proto.EnumName(Drive_Kind_name, int32(x))
}
func (Drive_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptorStore, []int{12, 0} }

type Bucket_API int32

const (
	Bucket_S3 Bucket_API = 0
)

var Bucket_API_name = map[int32]string{
	0: "S3",
}
var Bucket_API_value = map[string]int32{
	"S3": 0,
}

func (x Bucket_API) String() string {
	return proto.EnumName(Bucket_API_name, int32(x))
}
func (Bucket_API) EnumDescriptor() ([]byte, []int) { return fileDescriptorStore, []int{14, 0} }

type Index_Type int32

const (
	Index_BTREE    Index_Type = 0
	Index_PREFIX   Index_Type = 2
	Index_RTREE    Index_Type = 3
	Index_FULLTEXT Index_Type = 1
)

var Index_Type_name = map[int32]string{
	0: "BTREE",
	2: "PREFIX",
	3: "RTREE",
	1: "FULLTEXT",
}
var Index_Type_value = map[string]int32{
	"BTREE":    0,
	"PREFIX":   2,
	"RTREE":    3,
	"FULLTEXT": 1,
}

func (x Index_Type) String() string {
	return proto.EnumName(Index_Type_name, int32(x))
}
func (Index_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorStore, []int{18, 0} }

type Topic_Type int32

const (
	Topic_STANDARD Topic_Type = 0
)

var Topic_Type_name = map[int32]string{
	0: "STANDARD",
}
var Topic_Type_value = map[string]int32{
	"STANDARD": 0,
}

func (x Topic_Type) String() string {
	return proto.EnumName(Topic_Type_name, int32(x))
}
func (Topic_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorStore, []int{19, 0} }

type Topic_Mode int32

const (
	// Topic is used as a "Log"
	Topic_LOG Topic_Mode = 0
	// Topic is used as a "Job Queue"
	Topic_QUEUE Topic_Mode = 1
	// Tables allow for updates based on a specified "key"
	Topic_TABLE Topic_Mode = 2
	// Cache mode does not persist to disk
	Topic_CACHE Topic_Mode = 3
)

var Topic_Mode_name = map[int32]string{
	0: "LOG",
	1: "QUEUE",
	2: "TABLE",
	3: "CACHE",
}
var Topic_Mode_value = map[string]int32{
	"LOG":   0,
	"QUEUE": 1,
	"TABLE": 2,
	"CACHE": 3,
}

func (x Topic_Mode) String() string {
	return proto.EnumName(Topic_Mode_name, int32(x))
}
func (Topic_Mode) EnumDescriptor() ([]byte, []int) { return fileDescriptorStore, []int{19, 1} }

type Path_Type int32

const (
	Path_Local  Path_Type = 0
	Path_Bucket Path_Type = 1
)

var Path_Type_name = map[int32]string{
	0: "Local",
	1: "Bucket",
}
var Path_Type_value = map[string]int32{
	"Local":  0,
	"Bucket": 1,
}

func (x Path_Type) String() string {
	return proto.EnumName(Path_Type_name, int32(x))
}
func (Path_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorStore, []int{21, 0} }

type Hash_Algorithm int32

const (
	Hash_CRC32 Hash_Algorithm = 0
)

var Hash_Algorithm_name = map[int32]string{
	0: "CRC32",
}
var Hash_Algorithm_value = map[string]int32{
	"CRC32": 0,
}

func (x Hash_Algorithm) String() string {
	return proto.EnumName(Hash_Algorithm_name, int32(x))
}
func (Hash_Algorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptorStore, []int{22, 0} }

// Worker Application
type App struct {
	Id       uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name     string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc     string   `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	Versions []string `protobuf:"bytes,9,rep,name=versions" json:"versions,omitempty"`
	Tags     []string `protobuf:"bytes,10,rep,name=tags" json:"tags,omitempty"`
}

func (m *App) Reset()                    { *m = App{} }
func (m *App) String() string            { return proto.CompactTextString(m) }
func (*App) ProtoMessage()               {}
func (*App) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{0} }

func (m *App) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *App) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *App) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *App) GetVersions() []string {
	if m != nil {
		return m.Versions
	}
	return nil
}

func (m *App) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// A Processor node is a client app that connects to the cluster
// and can accept work to "process".
type Worker struct {
	Id      string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	Memory  int64  `protobuf:"varint,5,opt,name=memory,proto3" json:"memory,omitempty"`
	Cpus    int32  `protobuf:"varint,6,opt,name=cpus,proto3" json:"cpus,omitempty"`
	// List of queues it's able to process
	Queues []string `protobuf:"bytes,10,rep,name=queues" json:"queues,omitempty"`
}

func (m *Worker) Reset()                    { *m = Worker{} }
func (m *Worker) String() string            { return proto.CompactTextString(m) }
func (*Worker) ProtoMessage()               {}
func (*Worker) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{1} }

func (m *Worker) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Worker) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Worker) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Worker) GetMemory() int64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Worker) GetCpus() int32 {
	if m != nil {
		return m.Cpus
	}
	return 0
}

func (m *Worker) GetQueues() []string {
	if m != nil {
		return m.Queues
	}
	return nil
}

// slice/d Node
type Node struct {
	Id      string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Host    string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// VM / Server ID
	InstanceID string `protobuf:"bytes,4,opt,name=instanceID,proto3" json:"instanceID,omitempty"`
	// Datacenter region
	Region string `protobuf:"bytes,7,opt,name=region,proto3" json:"region,omitempty"`
	// Availability zone
	Zone     string `protobuf:"bytes,8,opt,name=zone,proto3" json:"zone,omitempty"`
	Cores    uint32 `protobuf:"varint,9,opt,name=cores,proto3" json:"cores,omitempty"`
	Memory   uint64 `protobuf:"varint,10,opt,name=memory,proto3" json:"memory,omitempty"`
	Os       string `protobuf:"bytes,50,opt,name=os,proto3" json:"os,omitempty"`
	Arch     string `protobuf:"bytes,51,opt,name=arch,proto3" json:"arch,omitempty"`
	CpuSpeed uint64 `protobuf:"varint,52,opt,name=cpuSpeed,proto3" json:"cpuSpeed,omitempty"`
	// Config
	Bootstrap bool   `protobuf:"varint,11,opt,name=bootstrap,proto3" json:"bootstrap,omitempty"`
	WebHost   string `protobuf:"bytes,12,opt,name=webHost,proto3" json:"webHost,omitempty"`
	ApiHost   string `protobuf:"bytes,13,opt,name=apiHost,proto3" json:"apiHost,omitempty"`
	ApiLoops  uint32 `protobuf:"varint,14,opt,name=apiLoops,proto3" json:"apiLoops,omitempty"`
	// Raft
	Member  *RaftMember `protobuf:"bytes,16,opt,name=member" json:"member,omitempty"`
	Created uint64      `protobuf:"fixed64,18,opt,name=created,proto3" json:"created,omitempty"`
	Inited  uint64      `protobuf:"fixed64,19,opt,name=inited,proto3" json:"inited,omitempty"`
	Changed uint64      `protobuf:"fixed64,20,opt,name=changed,proto3" json:"changed,omitempty"`
	Dropped uint64      `protobuf:"fixed64,21,opt,name=dropped,proto3" json:"dropped,omitempty"`
	Removed uint64      `protobuf:"fixed64,22,opt,name=removed,proto3" json:"removed,omitempty"`
	// Attached drives / volumes
	Drives []*Drive `protobuf:"bytes,24,rep,name=drives" json:"drives,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{2} }

func (m *Node) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Node) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Node) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Node) GetInstanceID() string {
	if m != nil {
		return m.InstanceID
	}
	return ""
}

func (m *Node) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *Node) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *Node) GetCores() uint32 {
	if m != nil {
		return m.Cores
	}
	return 0
}

func (m *Node) GetMemory() uint64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Node) GetOs() string {
	if m != nil {
		return m.Os
	}
	return ""
}

func (m *Node) GetArch() string {
	if m != nil {
		return m.Arch
	}
	return ""
}

func (m *Node) GetCpuSpeed() uint64 {
	if m != nil {
		return m.CpuSpeed
	}
	return 0
}

func (m *Node) GetBootstrap() bool {
	if m != nil {
		return m.Bootstrap
	}
	return false
}

func (m *Node) GetWebHost() string {
	if m != nil {
		return m.WebHost
	}
	return ""
}

func (m *Node) GetApiHost() string {
	if m != nil {
		return m.ApiHost
	}
	return ""
}

func (m *Node) GetApiLoops() uint32 {
	if m != nil {
		return m.ApiLoops
	}
	return 0
}

func (m *Node) GetMember() *RaftMember {
	if m != nil {
		return m.Member
	}
	return nil
}

func (m *Node) GetCreated() uint64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Node) GetInited() uint64 {
	if m != nil {
		return m.Inited
	}
	return 0
}

func (m *Node) GetChanged() uint64 {
	if m != nil {
		return m.Changed
	}
	return 0
}

func (m *Node) GetDropped() uint64 {
	if m != nil {
		return m.Dropped
	}
	return 0
}

func (m *Node) GetRemoved() uint64 {
	if m != nil {
		return m.Removed
	}
	return 0
}

func (m *Node) GetDrives() []*Drive {
	if m != nil {
		return m.Drives
	}
	return nil
}

type RaftMember struct {
	Id      string     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Address string     `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Status  RaftStatus `protobuf:"varint,3,opt,name=status,proto3,enum=store_pb.RaftStatus" json:"status,omitempty"`
	// Eventual suffrage status VOTER or NON_VOTER
	Membership Suffrage `protobuf:"varint,4,opt,name=membership,proto3,enum=store_pb.Suffrage" json:"membership,omitempty"`
	// Current Suffrage Status
	Suffrage Suffrage `protobuf:"varint,5,opt,name=suffrage,proto3,enum=store_pb.Suffrage" json:"suffrage,omitempty"`
	// Current term
	Term uint64 `protobuf:"varint,10,opt,name=term,proto3" json:"term,omitempty"`
	// Applied index
	Applied uint64 `protobuf:"varint,11,opt,name=applied,proto3" json:"applied,omitempty"`
}

func (m *RaftMember) Reset()                    { *m = RaftMember{} }
func (m *RaftMember) String() string            { return proto.CompactTextString(m) }
func (*RaftMember) ProtoMessage()               {}
func (*RaftMember) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{3} }

func (m *RaftMember) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RaftMember) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RaftMember) GetStatus() RaftStatus {
	if m != nil {
		return m.Status
	}
	return RaftStatus_FOLLOWER
}

func (m *RaftMember) GetMembership() Suffrage {
	if m != nil {
		return m.Membership
	}
	return Suffrage_VOTER
}

func (m *RaftMember) GetSuffrage() Suffrage {
	if m != nil {
		return m.Suffrage
	}
	return Suffrage_VOTER
}

func (m *RaftMember) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RaftMember) GetApplied() uint64 {
	if m != nil {
		return m.Applied
	}
	return 0
}

// A grouping of nodes that can form Slice Groups.
// Essentially this acts as a Raft Group template.
type NodeGroup struct {
	Id      int64               `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name    string              `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Members []*NodeGroup_Member `protobuf:"bytes,3,rep,name=members" json:"members,omitempty"`
	Slices  *Slice              `protobuf:"bytes,10,opt,name=slices" json:"slices,omitempty"`
}

func (m *NodeGroup) Reset()                    { *m = NodeGroup{} }
func (m *NodeGroup) String() string            { return proto.CompactTextString(m) }
func (*NodeGroup) ProtoMessage()               {}
func (*NodeGroup) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{4} }

func (m *NodeGroup) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *NodeGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeGroup) GetMembers() []*NodeGroup_Member {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *NodeGroup) GetSlices() *Slice {
	if m != nil {
		return m.Slices
	}
	return nil
}

type NodeGroup_Member struct {
	NodeID   string   `protobuf:"bytes,1,opt,name=nodeID,proto3" json:"nodeID,omitempty"`
	Suffrage Suffrage `protobuf:"varint,2,opt,name=suffrage,proto3,enum=store_pb.Suffrage" json:"suffrage,omitempty"`
}

func (m *NodeGroup_Member) Reset()                    { *m = NodeGroup_Member{} }
func (m *NodeGroup_Member) String() string            { return proto.CompactTextString(m) }
func (*NodeGroup_Member) ProtoMessage()               {}
func (*NodeGroup_Member) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{4, 0} }

func (m *NodeGroup_Member) GetNodeID() string {
	if m != nil {
		return m.NodeID
	}
	return ""
}

func (m *NodeGroup_Member) GetSuffrage() Suffrage {
	if m != nil {
		return m.Suffrage
	}
	return Suffrage_VOTER
}

type Database struct {
	Id          int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Created     uint64 `protobuf:"fixed64,4,opt,name=created,proto3" json:"created,omitempty"`
	Changed     uint64 `protobuf:"fixed64,5,opt,name=changed,proto3" json:"changed,omitempty"`
	Dropped     uint64 `protobuf:"fixed64,6,opt,name=dropped,proto3" json:"dropped,omitempty"`
	Removed     uint64 `protobuf:"fixed64,7,opt,name=removed,proto3" json:"removed,omitempty"`
	// Slices
	Slices []*Slice `protobuf:"bytes,10,rep,name=slices" json:"slices,omitempty"`
}

func (m *Database) Reset()                    { *m = Database{} }
func (m *Database) String() string            { return proto.CompactTextString(m) }
func (*Database) ProtoMessage()               {}
func (*Database) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{5} }

func (m *Database) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Database) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Database) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Database) GetCreated() uint64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Database) GetChanged() uint64 {
	if m != nil {
		return m.Changed
	}
	return 0
}

func (m *Database) GetDropped() uint64 {
	if m != nil {
		return m.Dropped
	}
	return 0
}

func (m *Database) GetRemoved() uint64 {
	if m != nil {
		return m.Removed
	}
	return 0
}

func (m *Database) GetSlices() []*Slice {
	if m != nil {
		return m.Slices
	}
	return nil
}

type SliceID struct {
	// Database ID
	DatabaseID int32 `protobuf:"varint,1,opt,name=databaseID,proto3" json:"databaseID,omitempty"`
	// Slice number
	SliceID int32 `protobuf:"varint,2,opt,name=sliceID,proto3" json:"sliceID,omitempty"`
}

func (m *SliceID) Reset()                    { *m = SliceID{} }
func (m *SliceID) String() string            { return proto.CompactTextString(m) }
func (*SliceID) ProtoMessage()               {}
func (*SliceID) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{6} }

func (m *SliceID) GetDatabaseID() int32 {
	if m != nil {
		return m.DatabaseID
	}
	return 0
}

func (m *SliceID) GetSliceID() int32 {
	if m != nil {
		return m.SliceID
	}
	return 0
}

// Each Slice has it's own Raft group and represents some
// range of the total slots of a database.
type Slice struct {
	Id *SliceID `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Ring
	Slots []*SlotRange `protobuf:"bytes,2,rep,name=slots" json:"slots,omitempty"`
	// Membership
	Nodes []*SliceNode `protobuf:"bytes,3,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *Slice) Reset()                    { *m = Slice{} }
func (m *Slice) String() string            { return proto.CompactTextString(m) }
func (*Slice) ProtoMessage()               {}
func (*Slice) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{7} }

func (m *Slice) GetId() *SliceID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Slice) GetSlots() []*SlotRange {
	if m != nil {
		return m.Slots
	}
	return nil
}

func (m *Slice) GetNodes() []*SliceNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type SliceNode struct {
	NodeID  string      `protobuf:"bytes,1,opt,name=nodeID,proto3" json:"nodeID,omitempty"`
	SliceID *SliceID    `protobuf:"bytes,2,opt,name=sliceID" json:"sliceID,omitempty"`
	Member  *RaftMember `protobuf:"bytes,3,opt,name=member" json:"member,omitempty"`
}

func (m *SliceNode) Reset()                    { *m = SliceNode{} }
func (m *SliceNode) String() string            { return proto.CompactTextString(m) }
func (*SliceNode) ProtoMessage()               {}
func (*SliceNode) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{8} }

func (m *SliceNode) GetNodeID() string {
	if m != nil {
		return m.NodeID
	}
	return ""
}

func (m *SliceNode) GetSliceID() *SliceID {
	if m != nil {
		return m.SliceID
	}
	return nil
}

func (m *SliceNode) GetMember() *RaftMember {
	if m != nil {
		return m.Member
	}
	return nil
}

type Rebalance struct {
	Timestamp int64             `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Tasks     []*Rebalance_Task `protobuf:"bytes,2,rep,name=tasks" json:"tasks,omitempty"`
}

func (m *Rebalance) Reset()                    { *m = Rebalance{} }
func (m *Rebalance) String() string            { return proto.CompactTextString(m) }
func (*Rebalance) ProtoMessage()               {}
func (*Rebalance) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{9} }

func (m *Rebalance) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Rebalance) GetTasks() []*Rebalance_Task {
	if m != nil {
		return m.Tasks
	}
	return nil
}

type Rebalance_Task struct {
	From  int32 `protobuf:"varint,1,opt,name=from,proto3" json:"from,omitempty"`
	To    int32 `protobuf:"varint,2,opt,name=to,proto3" json:"to,omitempty"`
	Low   int32 `protobuf:"varint,3,opt,name=low,proto3" json:"low,omitempty"`
	Count int32 `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *Rebalance_Task) Reset()                    { *m = Rebalance_Task{} }
func (m *Rebalance_Task) String() string            { return proto.CompactTextString(m) }
func (*Rebalance_Task) ProtoMessage()               {}
func (*Rebalance_Task) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{9, 0} }

func (m *Rebalance_Task) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *Rebalance_Task) GetTo() int32 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *Rebalance_Task) GetLow() int32 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *Rebalance_Task) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type Ring struct {
	Ranges []*SlotRange `protobuf:"bytes,2,rep,name=ranges" json:"ranges,omitempty"`
}

func (m *Ring) Reset()                    { *m = Ring{} }
func (m *Ring) String() string            { return proto.CompactTextString(m) }
func (*Ring) ProtoMessage()               {}
func (*Ring) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{10} }

func (m *Ring) GetRanges() []*SlotRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

type SlotRange struct {
	Slice int32 `protobuf:"varint,1,opt,name=slice,proto3" json:"slice,omitempty"`
	// The low slot
	Low int32 `protobuf:"varint,2,opt,name=low,proto3" json:"low,omitempty"`
	// The high slot
	High int32 `protobuf:"varint,3,opt,name=high,proto3" json:"high,omitempty"`
}

func (m *SlotRange) Reset()                    { *m = SlotRange{} }
func (m *SlotRange) String() string            { return proto.CompactTextString(m) }
func (*SlotRange) ProtoMessage()               {}
func (*SlotRange) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{11} }

func (m *SlotRange) GetSlice() int32 {
	if m != nil {
		return m.Slice
	}
	return 0
}

func (m *SlotRange) GetLow() int32 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *SlotRange) GetHigh() int32 {
	if m != nil {
		return m.High
	}
	return 0
}

// Locally mounted volume
type Drive struct {
	Mount      string      `protobuf:"bytes,1,opt,name=mount,proto3" json:"mount,omitempty"`
	Kind       Drive_Kind  `protobuf:"varint,2,opt,name=kind,proto3,enum=store_pb.Drive_Kind" json:"kind,omitempty"`
	Stats      *DriveStats `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
	Working    bool        `protobuf:"varint,4,opt,name=working,proto3" json:"working,omitempty"`
	FileSystem string      `protobuf:"bytes,5,opt,name=fileSystem,proto3" json:"fileSystem,omitempty"`
}

func (m *Drive) Reset()                    { *m = Drive{} }
func (m *Drive) String() string            { return proto.CompactTextString(m) }
func (*Drive) ProtoMessage()               {}
func (*Drive) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{12} }

func (m *Drive) GetMount() string {
	if m != nil {
		return m.Mount
	}
	return ""
}

func (m *Drive) GetKind() Drive_Kind {
	if m != nil {
		return m.Kind
	}
	return Drive_HDD
}

func (m *Drive) GetStats() *DriveStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *Drive) GetWorking() bool {
	if m != nil {
		return m.Working
	}
	return false
}

func (m *Drive) GetFileSystem() string {
	if m != nil {
		return m.FileSystem
	}
	return ""
}

type DriveStats struct {
	Size_ uint64 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	Used  uint64 `protobuf:"varint,2,opt,name=used,proto3" json:"used,omitempty"`
	Avail uint64 `protobuf:"varint,3,opt,name=avail,proto3" json:"avail,omitempty"`
}

func (m *DriveStats) Reset()                    { *m = DriveStats{} }
func (m *DriveStats) String() string            { return proto.CompactTextString(m) }
func (*DriveStats) ProtoMessage()               {}
func (*DriveStats) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{13} }

func (m *DriveStats) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *DriveStats) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *DriveStats) GetAvail() uint64 {
	if m != nil {
		return m.Avail
	}
	return 0
}

type Bucket struct {
	Id        string     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	AccessKey string     `protobuf:"bytes,2,opt,name=accessKey,proto3" json:"accessKey,omitempty"`
	SecretKey string     `protobuf:"bytes,3,opt,name=secretKey,proto3" json:"secretKey,omitempty"`
	Url       string     `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	Api       Bucket_API `protobuf:"varint,5,opt,name=api,proto3,enum=store_pb.Bucket_API" json:"api,omitempty"`
}

func (m *Bucket) Reset()                    { *m = Bucket{} }
func (m *Bucket) String() string            { return proto.CompactTextString(m) }
func (*Bucket) ProtoMessage()               {}
func (*Bucket) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{14} }

func (m *Bucket) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Bucket) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *Bucket) GetSecretKey() string {
	if m != nil {
		return m.SecretKey
	}
	return ""
}

func (m *Bucket) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Bucket) GetApi() Bucket_API {
	if m != nil {
		return m.Api
	}
	return Bucket_S3
}

type RecordID struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Seq   uint64 `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
}

func (m *RecordID) Reset()                    { *m = RecordID{} }
func (m *RecordID) String() string            { return proto.CompactTextString(m) }
func (*RecordID) ProtoMessage()               {}
func (*RecordID) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{15} }

func (m *RecordID) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *RecordID) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

type Record struct {
	Key   *Projection `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Slice *Projection `protobuf:"bytes,2,opt,name=slice" json:"slice,omitempty"`
}

func (m *Record) Reset()                    { *m = Record{} }
func (m *Record) String() string            { return proto.CompactTextString(m) }
func (*Record) ProtoMessage()               {}
func (*Record) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{16} }

func (m *Record) GetKey() *Projection {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Record) GetSlice() *Projection {
	if m != nil {
		return m.Slice
	}
	return nil
}

type Projection struct {
	Codec Codec    `protobuf:"varint,1,opt,name=codec,proto3,enum=store_pb.Codec" json:"codec,omitempty"`
	Names []string `protobuf:"bytes,2,rep,name=names" json:"names,omitempty"`
}

func (m *Projection) Reset()                    { *m = Projection{} }
func (m *Projection) String() string            { return proto.CompactTextString(m) }
func (*Projection) ProtoMessage()               {}
func (*Projection) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{17} }

func (m *Projection) GetCodec() Codec {
	if m != nil {
		return m.Codec
	}
	return Codec_JSON
}

func (m *Projection) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type Projection_Field struct {
	Id   int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Projection_Field) Reset()                    { *m = Projection_Field{} }
func (m *Projection_Field) String() string            { return proto.CompactTextString(m) }
func (*Projection_Field) ProtoMessage()               {}
func (*Projection_Field) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{17, 0} }

func (m *Projection_Field) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Projection_Field) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Index struct {
}

func (m *Index) Reset()                    { *m = Index{} }
func (m *Index) String() string            { return proto.CompactTextString(m) }
func (*Index) ProtoMessage()               {}
func (*Index) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{18} }

// Low level append-only log of user-defined records.
type Topic struct {
	Schema string `protobuf:"bytes,15,opt,name=schema,proto3" json:"schema,omitempty"`
	Id     int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name   string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Slot to default to if sliceKey isn't set
	Slot       uint32     `protobuf:"varint,3,opt,name=slot,proto3" json:"slot,omitempty"`
	Type       Topic_Type `protobuf:"varint,4,opt,name=type,proto3,enum=store_pb.Topic_Type" json:"type,omitempty"`
	QueueID    int64      `protobuf:"zigzag64,5,opt,name=queueID,proto3" json:"queueID,omitempty"`
	RollerID   string     `protobuf:"bytes,6,opt,name=rollerID,proto3" json:"rollerID,omitempty"`
	Mode       Topic_Mode `protobuf:"varint,7,opt,name=mode,proto3,enum=store_pb.Topic_Mode" json:"mode,omitempty"`
	WriteSpeed int32      `protobuf:"varint,8,opt,name=writeSpeed,proto3" json:"writeSpeed,omitempty"`
	Codec      Codec      `protobuf:"varint,9,opt,name=codec,proto3,enum=store_pb.Codec" json:"codec,omitempty"`
	// A "Keyed" topic (Primary Key) turns a topic into a table
	Key *Projection `protobuf:"bytes,10,opt,name=key" json:"key,omitempty"`
	// The key projection used to determines how to choose the right
	// slice / "shard" / "partition" based on a single record
	SliceKey *Projection `protobuf:"bytes,11,opt,name=sliceKey" json:"sliceKey,omitempty"`
	// Recommended Drive type
	Drive Drive_Kind `protobuf:"varint,12,opt,name=drive,proto3,enum=store_pb.Drive_Kind" json:"drive,omitempty"`
}

func (m *Topic) Reset()                    { *m = Topic{} }
func (m *Topic) String() string            { return proto.CompactTextString(m) }
func (*Topic) ProtoMessage()               {}
func (*Topic) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{19} }

func (m *Topic) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *Topic) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Topic) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Topic) GetSlot() uint32 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *Topic) GetType() Topic_Type {
	if m != nil {
		return m.Type
	}
	return Topic_STANDARD
}

func (m *Topic) GetQueueID() int64 {
	if m != nil {
		return m.QueueID
	}
	return 0
}

func (m *Topic) GetRollerID() string {
	if m != nil {
		return m.RollerID
	}
	return ""
}

func (m *Topic) GetMode() Topic_Mode {
	if m != nil {
		return m.Mode
	}
	return Topic_LOG
}

func (m *Topic) GetWriteSpeed() int32 {
	if m != nil {
		return m.WriteSpeed
	}
	return 0
}

func (m *Topic) GetCodec() Codec {
	if m != nil {
		return m.Codec
	}
	return Codec_JSON
}

func (m *Topic) GetKey() *Projection {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Topic) GetSliceKey() *Projection {
	if m != nil {
		return m.SliceKey
	}
	return nil
}

func (m *Topic) GetDrive() Drive_Kind {
	if m != nil {
		return m.Drive
	}
	return Drive_HDD
}

// Definition of a roller which decides when to create new segment files.
type Roller struct {
	Id       uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MinBytes uint64 `protobuf:"varint,3,opt,name=minBytes,proto3" json:"minBytes,omitempty"`
	MinAge   uint64 `protobuf:"varint,4,opt,name=minAge,proto3" json:"minAge,omitempty"`
	MinCount uint64 `protobuf:"varint,5,opt,name=minCount,proto3" json:"minCount,omitempty"`
	MaxBytes uint64 `protobuf:"varint,6,opt,name=maxBytes,proto3" json:"maxBytes,omitempty"`
	MaxAge   uint64 `protobuf:"varint,7,opt,name=maxAge,proto3" json:"maxAge,omitempty"`
	MaxCount uint64 `protobuf:"varint,8,opt,name=maxCount,proto3" json:"maxCount,omitempty"`
}

func (m *Roller) Reset()                    { *m = Roller{} }
func (m *Roller) String() string            { return proto.CompactTextString(m) }
func (*Roller) ProtoMessage()               {}
func (*Roller) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{20} }

func (m *Roller) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Roller) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Roller) GetMinBytes() uint64 {
	if m != nil {
		return m.MinBytes
	}
	return 0
}

func (m *Roller) GetMinAge() uint64 {
	if m != nil {
		return m.MinAge
	}
	return 0
}

func (m *Roller) GetMinCount() uint64 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

func (m *Roller) GetMaxBytes() uint64 {
	if m != nil {
		return m.MaxBytes
	}
	return 0
}

func (m *Roller) GetMaxAge() uint64 {
	if m != nil {
		return m.MaxAge
	}
	return 0
}

func (m *Roller) GetMaxCount() uint64 {
	if m != nil {
		return m.MaxCount
	}
	return 0
}

type Path struct {
	// Name of file
	// This is a path string scoped under a volume
	// /volume/drive
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Volume ID
	VolumeID string `protobuf:"bytes,2,opt,name=volumeID,proto3" json:"volumeID,omitempty"`
	// Drive
	Drive string `protobuf:"bytes,3,opt,name=drive,proto3" json:"drive,omitempty"`
	// Flag whether file is local
	Local bool `protobuf:"varint,4,opt,name=local,proto3" json:"local,omitempty"`
	// Flag whether file is in a remote bucket
	Bucket bool `protobuf:"varint,5,opt,name=bucket,proto3" json:"bucket,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{21} }

func (m *Path) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Path) GetVolumeID() string {
	if m != nil {
		return m.VolumeID
	}
	return ""
}

func (m *Path) GetDrive() string {
	if m != nil {
		return m.Drive
	}
	return ""
}

func (m *Path) GetLocal() bool {
	if m != nil {
		return m.Local
	}
	return false
}

func (m *Path) GetBucket() bool {
	if m != nil {
		return m.Bucket
	}
	return false
}

type Hash struct {
	Algorithm string `protobuf:"bytes,1,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	Value     []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Hash) Reset()                    { *m = Hash{} }
func (m *Hash) String() string            { return proto.CompactTextString(m) }
func (*Hash) ProtoMessage()               {}
func (*Hash) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{22} }

func (m *Hash) GetAlgorithm() string {
	if m != nil {
		return m.Algorithm
	}
	return ""
}

func (m *Hash) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// An appender will eventually seal it's current file
// and start appending to a brand new file. These files
// are called "Segments".
type Segment struct {
	// Sequence of the segment within a topic
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// ID of the stream
	TopicID int64 `protobuf:"zigzag64,2,opt,name=topicID,proto3" json:"topicID,omitempty"`
	// Slice that owns the segment
	Slice int32 `protobuf:"varint,3,opt,name=slice,proto3" json:"slice,omitempty"`
	// Location of file
	Path *Path `protobuf:"bytes,4,opt,name=path" json:"path,omitempty"`
	// Header
	Header *SegmentHeader `protobuf:"bytes,5,opt,name=header" json:"header,omitempty"`
	// Stats of a single segment
	Stats *SegmentStats `protobuf:"bytes,6,opt,name=stats" json:"stats,omitempty"`
}

func (m *Segment) Reset()                    { *m = Segment{} }
func (m *Segment) String() string            { return proto.CompactTextString(m) }
func (*Segment) ProtoMessage()               {}
func (*Segment) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{23} }

func (m *Segment) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Segment) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *Segment) GetSlice() int32 {
	if m != nil {
		return m.Slice
	}
	return 0
}

func (m *Segment) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Segment) GetHeader() *SegmentHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Segment) GetStats() *SegmentStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type SegmentStats struct {
	// Hash of the entire contents of the file
	Hash *Hash `protobuf:"bytes,1,opt,name=hash" json:"hash,omitempty"`
	// Number of records
	Count uint64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// Cumulative size of all headers in bytes
	Header uint64 `protobuf:"varint,3,opt,name=header,proto3" json:"header,omitempty"`
	// Cumulative size of all bodies in bytes
	Body uint64 `protobuf:"varint,4,opt,name=body,proto3" json:"body,omitempty"`
	// Size of entire file in bytes
	Size_ int64 `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	// The size in bytes of the largest body
	MaxBody uint32 `protobuf:"varint,6,opt,name=maxBody,proto3" json:"maxBody,omitempty"`
	// First record
	First *RecordPointer `protobuf:"bytes,7,opt,name=first" json:"first,omitempty"`
	// Last record
	Last *RecordPointer `protobuf:"bytes,8,opt,name=last" json:"last,omitempty"`
}

func (m *SegmentStats) Reset()                    { *m = SegmentStats{} }
func (m *SegmentStats) String() string            { return proto.CompactTextString(m) }
func (*SegmentStats) ProtoMessage()               {}
func (*SegmentStats) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{24} }

func (m *SegmentStats) GetHash() *Hash {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *SegmentStats) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *SegmentStats) GetHeader() uint64 {
	if m != nil {
		return m.Header
	}
	return 0
}

func (m *SegmentStats) GetBody() uint64 {
	if m != nil {
		return m.Body
	}
	return 0
}

func (m *SegmentStats) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SegmentStats) GetMaxBody() uint32 {
	if m != nil {
		return m.MaxBody
	}
	return 0
}

func (m *SegmentStats) GetFirst() *RecordPointer {
	if m != nil {
		return m.First
	}
	return nil
}

func (m *SegmentStats) GetLast() *RecordPointer {
	if m != nil {
		return m.Last
	}
	return nil
}

type SegmentHeader struct {
	Timestamp  uint64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	TopicID    int64  `protobuf:"zigzag64,2,opt,name=topicID,proto3" json:"topicID,omitempty"`
	LogID      uint64 `protobuf:"varint,3,opt,name=logID,proto3" json:"logID,omitempty"`
	StartIndex int64  `protobuf:"varint,4,opt,name=startIndex,proto3" json:"startIndex,omitempty"`
}

func (m *SegmentHeader) Reset()                    { *m = SegmentHeader{} }
func (m *SegmentHeader) String() string            { return proto.CompactTextString(m) }
func (*SegmentHeader) ProtoMessage()               {}
func (*SegmentHeader) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{25} }

func (m *SegmentHeader) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SegmentHeader) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *SegmentHeader) GetLogID() uint64 {
	if m != nil {
		return m.LogID
	}
	return 0
}

func (m *SegmentHeader) GetStartIndex() int64 {
	if m != nil {
		return m.StartIndex
	}
	return 0
}

type GlobalID struct {
	Id    int64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Slot  int32     `protobuf:"varint,2,opt,name=slot,proto3" json:"slot,omitempty"`
	RecID *RecordID `protobuf:"bytes,3,opt,name=recID" json:"recID,omitempty"`
}

func (m *GlobalID) Reset()                    { *m = GlobalID{} }
func (m *GlobalID) String() string            { return proto.CompactTextString(m) }
func (*GlobalID) ProtoMessage()               {}
func (*GlobalID) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{26} }

func (m *GlobalID) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GlobalID) GetSlot() int32 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *GlobalID) GetRecID() *RecordID {
	if m != nil {
		return m.RecID
	}
	return nil
}

type RecordPointer struct {
	Id *RecordID `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Log ID
	LogID uint64 `protobuf:"varint,2,opt,name=logID,proto3" json:"logID,omitempty"`
	// Slot
	Slot uint32 `protobuf:"varint,3,opt,name=slot,proto3" json:"slot,omitempty"`
	// Size of the body
	Size_ uint32 `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	// Position of first byte of the body
	Pos int64 `protobuf:"varint,5,opt,name=pos,proto3" json:"pos,omitempty"`
}

func (m *RecordPointer) Reset()                    { *m = RecordPointer{} }
func (m *RecordPointer) String() string            { return proto.CompactTextString(m) }
func (*RecordPointer) ProtoMessage()               {}
func (*RecordPointer) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{27} }

func (m *RecordPointer) GetId() *RecordID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RecordPointer) GetLogID() uint64 {
	if m != nil {
		return m.LogID
	}
	return 0
}

func (m *RecordPointer) GetSlot() uint32 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *RecordPointer) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *RecordPointer) GetPos() int64 {
	if m != nil {
		return m.Pos
	}
	return 0
}

// Queue or Message Queue is a higher level construct that manage the
// lifecycle of a Job queue. 3 topics are constructed.
type Queue struct {
	Id        uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	RequestID uint64 `protobuf:"varint,3,opt,name=requestID,proto3" json:"requestID,omitempty"`
	// ACK stream ID
	ReplyID uint64 `protobuf:"varint,4,opt,name=replyID,proto3" json:"replyID,omitempty"`
	// ERR or Dead-Letter stream
	ErrorID uint64 `protobuf:"varint,5,opt,name=errorID,proto3" json:"errorID,omitempty"`
	// Management level
	Level Level `protobuf:"varint,6,opt,name=level,proto3,enum=store_pb.Level" json:"level,omitempty"`
	// Fifo order
	Fifo          bool     `protobuf:"varint,10,opt,name=fifo,proto3" json:"fifo,omitempty"`
	MaxInflight   uint64   `protobuf:"varint,11,opt,name=maxInflight,proto3" json:"maxInflight,omitempty"`
	MaxVisibility uint64   `protobuf:"varint,12,opt,name=maxVisibility,proto3" json:"maxVisibility,omitempty"`
	MaxDelay      uint64   `protobuf:"varint,13,opt,name=maxDelay,proto3" json:"maxDelay,omitempty"`
	MaxRetries    uint32   `protobuf:"varint,14,opt,name=maxRetries,proto3" json:"maxRetries,omitempty"`
	AppID         string   `protobuf:"bytes,15,opt,name=appID,proto3" json:"appID,omitempty"`
	Tags          []string `protobuf:"bytes,16,rep,name=tags" json:"tags,omitempty"`
}

func (m *Queue) Reset()                    { *m = Queue{} }
func (m *Queue) String() string            { return proto.CompactTextString(m) }
func (*Queue) ProtoMessage()               {}
func (*Queue) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{28} }

func (m *Queue) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Queue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Queue) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *Queue) GetReplyID() uint64 {
	if m != nil {
		return m.ReplyID
	}
	return 0
}

func (m *Queue) GetErrorID() uint64 {
	if m != nil {
		return m.ErrorID
	}
	return 0
}

func (m *Queue) GetLevel() Level {
	if m != nil {
		return m.Level
	}
	return Level_MISSION
}

func (m *Queue) GetFifo() bool {
	if m != nil {
		return m.Fifo
	}
	return false
}

func (m *Queue) GetMaxInflight() uint64 {
	if m != nil {
		return m.MaxInflight
	}
	return 0
}

func (m *Queue) GetMaxVisibility() uint64 {
	if m != nil {
		return m.MaxVisibility
	}
	return 0
}

func (m *Queue) GetMaxDelay() uint64 {
	if m != nil {
		return m.MaxDelay
	}
	return 0
}

func (m *Queue) GetMaxRetries() uint32 {
	if m != nil {
		return m.MaxRetries
	}
	return 0
}

func (m *Queue) GetAppID() string {
	if m != nil {
		return m.AppID
	}
	return ""
}

func (m *Queue) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type Daemon struct {
	Id    uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name  string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Level Level  `protobuf:"varint,3,opt,name=level,proto3,enum=store_pb.Level" json:"level,omitempty"`
}

func (m *Daemon) Reset()                    { *m = Daemon{} }
func (m *Daemon) String() string            { return proto.CompactTextString(m) }
func (*Daemon) ProtoMessage()               {}
func (*Daemon) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{29} }

func (m *Daemon) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Daemon) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Daemon) GetLevel() Level {
	if m != nil {
		return m.Level
	}
	return Level_MISSION
}

type InitNode struct {
	Node *Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
}

func (m *InitNode) Reset()                    { *m = InitNode{} }
func (m *InitNode) String() string            { return proto.CompactTextString(m) }
func (*InitNode) ProtoMessage()               {}
func (*InitNode) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{30} }

func (m *InitNode) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type AddNodeToGroup struct {
	NodeID    string   `protobuf:"bytes,1,opt,name=nodeID,proto3" json:"nodeID,omitempty"`
	GroupID   int64    `protobuf:"varint,2,opt,name=groupID,proto3" json:"groupID,omitempty"`
	Suffrage  Suffrage `protobuf:"varint,3,opt,name=suffrage,proto3,enum=store_pb.Suffrage" json:"suffrage,omitempty"`
	Bootstrap bool     `protobuf:"varint,4,opt,name=bootstrap,proto3" json:"bootstrap,omitempty"`
}

func (m *AddNodeToGroup) Reset()                    { *m = AddNodeToGroup{} }
func (m *AddNodeToGroup) String() string            { return proto.CompactTextString(m) }
func (*AddNodeToGroup) ProtoMessage()               {}
func (*AddNodeToGroup) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{31} }

func (m *AddNodeToGroup) GetNodeID() string {
	if m != nil {
		return m.NodeID
	}
	return ""
}

func (m *AddNodeToGroup) GetGroupID() int64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *AddNodeToGroup) GetSuffrage() Suffrage {
	if m != nil {
		return m.Suffrage
	}
	return Suffrage_VOTER
}

func (m *AddNodeToGroup) GetBootstrap() bool {
	if m != nil {
		return m.Bootstrap
	}
	return false
}

type CreateDatabaseRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CreateDatabaseRequest) Reset()                    { *m = CreateDatabaseRequest{} }
func (m *CreateDatabaseRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateDatabaseRequest) ProtoMessage()               {}
func (*CreateDatabaseRequest) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{32} }

func (m *CreateDatabaseRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type CreateDatabaseReply struct {
}

func (m *CreateDatabaseReply) Reset()                    { *m = CreateDatabaseReply{} }
func (m *CreateDatabaseReply) String() string            { return proto.CompactTextString(m) }
func (*CreateDatabaseReply) ProtoMessage()               {}
func (*CreateDatabaseReply) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{33} }

type TxCreateTopic struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Level  Level  `protobuf:"varint,2,opt,name=level,proto3,enum=store_pb.Level" json:"level,omitempty"`
	Roller string `protobuf:"bytes,3,opt,name=roller,proto3" json:"roller,omitempty"`
	AppID  string `protobuf:"bytes,4,opt,name=appID,proto3" json:"appID,omitempty"`
}

func (m *TxCreateTopic) Reset()                    { *m = TxCreateTopic{} }
func (m *TxCreateTopic) String() string            { return proto.CompactTextString(m) }
func (*TxCreateTopic) ProtoMessage()               {}
func (*TxCreateTopic) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{34} }

func (m *TxCreateTopic) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TxCreateTopic) GetLevel() Level {
	if m != nil {
		return m.Level
	}
	return Level_MISSION
}

func (m *TxCreateTopic) GetRoller() string {
	if m != nil {
		return m.Roller
	}
	return ""
}

func (m *TxCreateTopic) GetAppID() string {
	if m != nil {
		return m.AppID
	}
	return ""
}

type TxCreateQueue struct {
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Level         Level  `protobuf:"varint,2,opt,name=level,proto3,enum=store_pb.Level" json:"level,omitempty"`
	Roller        string `protobuf:"bytes,3,opt,name=roller,proto3" json:"roller,omitempty"`
	Fifo          bool   `protobuf:"varint,5,opt,name=fifo,proto3" json:"fifo,omitempty"`
	MaxInflight   uint64 `protobuf:"varint,6,opt,name=maxInflight,proto3" json:"maxInflight,omitempty"`
	MaxVisibility uint64 `protobuf:"varint,7,opt,name=maxVisibility,proto3" json:"maxVisibility,omitempty"`
	MaxDelay      uint64 `protobuf:"varint,8,opt,name=maxDelay,proto3" json:"maxDelay,omitempty"`
	MaxRetries    uint32 `protobuf:"varint,9,opt,name=maxRetries,proto3" json:"maxRetries,omitempty"`
	AppID         string `protobuf:"bytes,10,opt,name=appID,proto3" json:"appID,omitempty"`
}

func (m *TxCreateQueue) Reset()                    { *m = TxCreateQueue{} }
func (m *TxCreateQueue) String() string            { return proto.CompactTextString(m) }
func (*TxCreateQueue) ProtoMessage()               {}
func (*TxCreateQueue) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{35} }

func (m *TxCreateQueue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TxCreateQueue) GetLevel() Level {
	if m != nil {
		return m.Level
	}
	return Level_MISSION
}

func (m *TxCreateQueue) GetRoller() string {
	if m != nil {
		return m.Roller
	}
	return ""
}

func (m *TxCreateQueue) GetFifo() bool {
	if m != nil {
		return m.Fifo
	}
	return false
}

func (m *TxCreateQueue) GetMaxInflight() uint64 {
	if m != nil {
		return m.MaxInflight
	}
	return 0
}

func (m *TxCreateQueue) GetMaxVisibility() uint64 {
	if m != nil {
		return m.MaxVisibility
	}
	return 0
}

func (m *TxCreateQueue) GetMaxDelay() uint64 {
	if m != nil {
		return m.MaxDelay
	}
	return 0
}

func (m *TxCreateQueue) GetMaxRetries() uint32 {
	if m != nil {
		return m.MaxRetries
	}
	return 0
}

func (m *TxCreateQueue) GetAppID() string {
	if m != nil {
		return m.AppID
	}
	return ""
}

type TxCreateSegment struct {
}

func (m *TxCreateSegment) Reset()                    { *m = TxCreateSegment{} }
func (m *TxCreateSegment) String() string            { return proto.CompactTextString(m) }
func (*TxCreateSegment) ProtoMessage()               {}
func (*TxCreateSegment) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{36} }

type TxRoll struct {
	RollerID int64 `protobuf:"varint,1,opt,name=rollerID,proto3" json:"rollerID,omitempty"`
}

func (m *TxRoll) Reset()                    { *m = TxRoll{} }
func (m *TxRoll) String() string            { return proto.CompactTextString(m) }
func (*TxRoll) ProtoMessage()               {}
func (*TxRoll) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{37} }

func (m *TxRoll) GetRollerID() int64 {
	if m != nil {
		return m.RollerID
	}
	return 0
}

type TxDeleteTopic struct {
}

func (m *TxDeleteTopic) Reset()                    { *m = TxDeleteTopic{} }
func (m *TxDeleteTopic) String() string            { return proto.CompactTextString(m) }
func (*TxDeleteTopic) ProtoMessage()               {}
func (*TxDeleteTopic) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{38} }

type TxChangeRing struct {
	From []*Slice `protobuf:"bytes,1,rep,name=from" json:"from,omitempty"`
	To   []*Slice `protobuf:"bytes,2,rep,name=to" json:"to,omitempty"`
}

func (m *TxChangeRing) Reset()                    { *m = TxChangeRing{} }
func (m *TxChangeRing) String() string            { return proto.CompactTextString(m) }
func (*TxChangeRing) ProtoMessage()               {}
func (*TxChangeRing) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{39} }

func (m *TxChangeRing) GetFrom() []*Slice {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *TxChangeRing) GetTo() []*Slice {
	if m != nil {
		return m.To
	}
	return nil
}

type TxChangeRingCancel struct {
}

func (m *TxChangeRingCancel) Reset()                    { *m = TxChangeRingCancel{} }
func (m *TxChangeRingCancel) String() string            { return proto.CompactTextString(m) }
func (*TxChangeRingCancel) ProtoMessage()               {}
func (*TxChangeRingCancel) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{40} }

// Splits a topic based on a new ring signature
type TxSplitTopic struct {
}

func (m *TxSplitTopic) Reset()                    { *m = TxSplitTopic{} }
func (m *TxSplitTopic) String() string            { return proto.CompactTextString(m) }
func (*TxSplitTopic) ProtoMessage()               {}
func (*TxSplitTopic) Descriptor() ([]byte, []int) { return fileDescriptorStore, []int{41} }

func init() {
	proto.RegisterType((*App)(nil), "store_pb.App")
	proto.RegisterType((*Worker)(nil), "store_pb.Worker")
	proto.RegisterType((*Node)(nil), "store_pb.Node")
	proto.RegisterType((*RaftMember)(nil), "store_pb.RaftMember")
	proto.RegisterType((*NodeGroup)(nil), "store_pb.NodeGroup")
	proto.RegisterType((*NodeGroup_Member)(nil), "store_pb.NodeGroup.Member")
	proto.RegisterType((*Database)(nil), "store_pb.Database")
	proto.RegisterType((*SliceID)(nil), "store_pb.SliceID")
	proto.RegisterType((*Slice)(nil), "store_pb.Slice")
	proto.RegisterType((*SliceNode)(nil), "store_pb.SliceNode")
	proto.RegisterType((*Rebalance)(nil), "store_pb.Rebalance")
	proto.RegisterType((*Rebalance_Task)(nil), "store_pb.Rebalance.Task")
	proto.RegisterType((*Ring)(nil), "store_pb.Ring")
	proto.RegisterType((*SlotRange)(nil), "store_pb.SlotRange")
	proto.RegisterType((*Drive)(nil), "store_pb.Drive")
	proto.RegisterType((*DriveStats)(nil), "store_pb.DriveStats")
	proto.RegisterType((*Bucket)(nil), "store_pb.Bucket")
	proto.RegisterType((*RecordID)(nil), "store_pb.RecordID")
	proto.RegisterType((*Record)(nil), "store_pb.Record")
	proto.RegisterType((*Projection)(nil), "store_pb.Projection")
	proto.RegisterType((*Projection_Field)(nil), "store_pb.Projection.Field")
	proto.RegisterType((*Index)(nil), "store_pb.Index")
	proto.RegisterType((*Topic)(nil), "store_pb.Topic")
	proto.RegisterType((*Roller)(nil), "store_pb.Roller")
	proto.RegisterType((*Path)(nil), "store_pb.Path")
	proto.RegisterType((*Hash)(nil), "store_pb.Hash")
	proto.RegisterType((*Segment)(nil), "store_pb.Segment")
	proto.RegisterType((*SegmentStats)(nil), "store_pb.SegmentStats")
	proto.RegisterType((*SegmentHeader)(nil), "store_pb.SegmentHeader")
	proto.RegisterType((*GlobalID)(nil), "store_pb.GlobalID")
	proto.RegisterType((*RecordPointer)(nil), "store_pb.RecordPointer")
	proto.RegisterType((*Queue)(nil), "store_pb.Queue")
	proto.RegisterType((*Daemon)(nil), "store_pb.Daemon")
	proto.RegisterType((*InitNode)(nil), "store_pb.InitNode")
	proto.RegisterType((*AddNodeToGroup)(nil), "store_pb.AddNodeToGroup")
	proto.RegisterType((*CreateDatabaseRequest)(nil), "store_pb.CreateDatabaseRequest")
	proto.RegisterType((*CreateDatabaseReply)(nil), "store_pb.CreateDatabaseReply")
	proto.RegisterType((*TxCreateTopic)(nil), "store_pb.TxCreateTopic")
	proto.RegisterType((*TxCreateQueue)(nil), "store_pb.TxCreateQueue")
	proto.RegisterType((*TxCreateSegment)(nil), "store_pb.TxCreateSegment")
	proto.RegisterType((*TxRoll)(nil), "store_pb.TxRoll")
	proto.RegisterType((*TxDeleteTopic)(nil), "store_pb.TxDeleteTopic")
	proto.RegisterType((*TxChangeRing)(nil), "store_pb.TxChangeRing")
	proto.RegisterType((*TxChangeRingCancel)(nil), "store_pb.TxChangeRingCancel")
	proto.RegisterType((*TxSplitTopic)(nil), "store_pb.TxSplitTopic")
	proto.RegisterEnum("store_pb.Level", Level_name, Level_value)
	proto.RegisterEnum("store_pb.Codec", Codec_name, Codec_value)
	proto.RegisterEnum("store_pb.Suffrage", Suffrage_name, Suffrage_value)
	proto.RegisterEnum("store_pb.RaftStatus", RaftStatus_name, RaftStatus_value)
	proto.RegisterEnum("store_pb.Drive_Kind", Drive_Kind_name, Drive_Kind_value)
	proto.RegisterEnum("store_pb.Bucket_API", Bucket_API_name, Bucket_API_value)
	proto.RegisterEnum("store_pb.Index_Type", Index_Type_name, Index_Type_value)
	proto.RegisterEnum("store_pb.Topic_Type", Topic_Type_name, Topic_Type_value)
	proto.RegisterEnum("store_pb.Topic_Mode", Topic_Mode_name, Topic_Mode_value)
	proto.RegisterEnum("store_pb.Path_Type", Path_Type_name, Path_Type_value)
	proto.RegisterEnum("store_pb.Hash_Algorithm", Hash_Algorithm_name, Hash_Algorithm_value)
}
func (m *App) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Versions) > 0 {
		for _, s := range m.Versions {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Worker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Worker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Memory != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Memory))
	}
	if m.Cpus != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Cpus))
	}
	if len(m.Queues) > 0 {
		for _, s := range m.Queues {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Host) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.InstanceID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.InstanceID)))
		i += copy(dAtA[i:], m.InstanceID)
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if len(m.Zone) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if m.Cores != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Cores))
	}
	if m.Memory != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Memory))
	}
	if m.Bootstrap {
		dAtA[i] = 0x58
		i++
		if m.Bootstrap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.WebHost) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.WebHost)))
		i += copy(dAtA[i:], m.WebHost)
	}
	if len(m.ApiHost) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.ApiHost)))
		i += copy(dAtA[i:], m.ApiHost)
	}
	if m.ApiLoops != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.ApiLoops))
	}
	if m.Member != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Member.Size()))
		n1, err := m.Member.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Created != 0 {
		dAtA[i] = 0x91
		i++
		dAtA[i] = 0x1
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Created))
		i += 8
	}
	if m.Inited != 0 {
		dAtA[i] = 0x99
		i++
		dAtA[i] = 0x1
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Inited))
		i += 8
	}
	if m.Changed != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x1
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Changed))
		i += 8
	}
	if m.Dropped != 0 {
		dAtA[i] = 0xa9
		i++
		dAtA[i] = 0x1
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Dropped))
		i += 8
	}
	if m.Removed != 0 {
		dAtA[i] = 0xb1
		i++
		dAtA[i] = 0x1
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Removed))
		i += 8
	}
	if len(m.Drives) > 0 {
		for _, msg := range m.Drives {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintStore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Os) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Os)))
		i += copy(dAtA[i:], m.Os)
	}
	if len(m.Arch) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Arch)))
		i += copy(dAtA[i:], m.Arch)
	}
	if m.CpuSpeed != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.CpuSpeed))
	}
	return i, nil
}

func (m *RaftMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftMember) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Status))
	}
	if m.Membership != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Membership))
	}
	if m.Suffrage != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Suffrage))
	}
	if m.Term != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Term))
	}
	if m.Applied != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Applied))
	}
	return i, nil
}

func (m *NodeGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Members) > 0 {
		for _, msg := range m.Members {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintStore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Slices != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Slices.Size()))
		n2, err := m.Slices.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *NodeGroup_Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeGroup_Member) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.NodeID)))
		i += copy(dAtA[i:], m.NodeID)
	}
	if m.Suffrage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Suffrage))
	}
	return i, nil
}

func (m *Database) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Database) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Created != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Created))
		i += 8
	}
	if m.Changed != 0 {
		dAtA[i] = 0x29
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Changed))
		i += 8
	}
	if m.Dropped != 0 {
		dAtA[i] = 0x31
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Dropped))
		i += 8
	}
	if m.Removed != 0 {
		dAtA[i] = 0x39
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Removed))
		i += 8
	}
	if len(m.Slices) > 0 {
		for _, msg := range m.Slices {
			dAtA[i] = 0x52
			i++
			i = encodeVarintStore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SliceID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SliceID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DatabaseID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.DatabaseID))
	}
	if m.SliceID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.SliceID))
	}
	return i, nil
}

func (m *Slice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Slice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Id.Size()))
		n3, err := m.Id.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Slots) > 0 {
		for _, msg := range m.Slots {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintStore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SliceNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SliceNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.NodeID)))
		i += copy(dAtA[i:], m.NodeID)
	}
	if m.SliceID != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.SliceID.Size()))
		n4, err := m.SliceID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Member != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Member.Size()))
		n5, err := m.Member.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *Rebalance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rebalance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Timestamp))
	}
	if len(m.Tasks) > 0 {
		for _, msg := range m.Tasks {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Rebalance_Task) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rebalance_Task) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.From != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.From))
	}
	if m.To != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.To))
	}
	if m.Low != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Low))
	}
	if m.Count != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *Ring) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ring) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SlotRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlotRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Slice != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Slice))
	}
	if m.Low != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Low))
	}
	if m.High != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.High))
	}
	return i, nil
}

func (m *Drive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Drive) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mount) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Mount)))
		i += copy(dAtA[i:], m.Mount)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Kind))
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Stats.Size()))
		n6, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Working {
		dAtA[i] = 0x20
		i++
		if m.Working {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.FileSystem) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.FileSystem)))
		i += copy(dAtA[i:], m.FileSystem)
	}
	return i, nil
}

func (m *DriveStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DriveStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Size_))
	}
	if m.Used != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Used))
	}
	if m.Avail != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Avail))
	}
	return i, nil
}

func (m *Bucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bucket) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.AccessKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.AccessKey)))
		i += copy(dAtA[i:], m.AccessKey)
	}
	if len(m.SecretKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.SecretKey)))
		i += copy(dAtA[i:], m.SecretKey)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.Api != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Api))
	}
	return i, nil
}

func (m *RecordID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Epoch))
	}
	if m.Seq != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Seq))
	}
	return i, nil
}

func (m *Record) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Record) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Key.Size()))
		n7, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Slice != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Slice.Size()))
		n8, err := m.Slice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *Projection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Projection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Codec != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Codec))
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Projection_Field) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Projection_Field) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *Index) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Index) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Topic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Topic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Slot != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Slot))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Type))
	}
	if m.QueueID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStore(dAtA, i, uint64((uint64(m.QueueID)<<1)^uint64((m.QueueID>>63))))
	}
	if len(m.RollerID) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.RollerID)))
		i += copy(dAtA[i:], m.RollerID)
	}
	if m.Mode != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Mode))
	}
	if m.WriteSpeed != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.WriteSpeed))
	}
	if m.Codec != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Codec))
	}
	if m.Key != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Key.Size()))
		n9, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.SliceKey != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.SliceKey.Size()))
		n10, err := m.SliceKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Drive != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Drive))
	}
	if len(m.Schema) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Schema)))
		i += copy(dAtA[i:], m.Schema)
	}
	return i, nil
}

func (m *Roller) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Roller) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.MinBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MinBytes))
	}
	if m.MinAge != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MinAge))
	}
	if m.MinCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MinCount))
	}
	if m.MaxBytes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MaxBytes))
	}
	if m.MaxAge != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MaxAge))
	}
	if m.MaxCount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MaxCount))
	}
	return i, nil
}

func (m *Path) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Path) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.VolumeID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.VolumeID)))
		i += copy(dAtA[i:], m.VolumeID)
	}
	if len(m.Drive) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Drive)))
		i += copy(dAtA[i:], m.Drive)
	}
	if m.Local {
		dAtA[i] = 0x20
		i++
		if m.Local {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Bucket {
		dAtA[i] = 0x28
		i++
		if m.Bucket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Hash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Hash) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Algorithm) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Algorithm)))
		i += copy(dAtA[i:], m.Algorithm)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *Segment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Segment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Id))
	}
	if m.TopicID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64((uint64(m.TopicID)<<1)^uint64((m.TopicID>>63))))
	}
	if m.Slice != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Slice))
	}
	if m.Path != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Path.Size()))
		n11, err := m.Path.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Header != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Header.Size()))
		n12, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Stats != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Stats.Size()))
		n13, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *SegmentStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegmentStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hash != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Hash.Size()))
		n14, err := m.Hash.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Count))
	}
	if m.Header != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Header))
	}
	if m.Body != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Body))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Size_))
	}
	if m.MaxBody != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MaxBody))
	}
	if m.First != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.First.Size()))
		n15, err := m.First.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Last != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Last.Size()))
		n16, err := m.Last.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *SegmentHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegmentHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Timestamp))
	}
	if m.TopicID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64((uint64(m.TopicID)<<1)^uint64((m.TopicID>>63))))
	}
	if m.LogID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.LogID))
	}
	if m.StartIndex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.StartIndex))
	}
	return i, nil
}

func (m *GlobalID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Id))
	}
	if m.Slot != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Slot))
	}
	if m.RecID != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.RecID.Size()))
		n17, err := m.RecID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *RecordPointer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordPointer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Id.Size()))
		n18, err := m.Id.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.LogID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.LogID))
	}
	if m.Slot != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Slot))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Size_))
	}
	if m.Pos != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Pos))
	}
	return i, nil
}

func (m *Queue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Queue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.RequestID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.RequestID))
	}
	if m.ReplyID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.ReplyID))
	}
	if m.ErrorID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.ErrorID))
	}
	if m.Level != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Level))
	}
	if m.Fifo {
		dAtA[i] = 0x50
		i++
		if m.Fifo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxInflight != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MaxInflight))
	}
	if m.MaxVisibility != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MaxVisibility))
	}
	if m.MaxDelay != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MaxDelay))
	}
	if m.MaxRetries != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MaxRetries))
	}
	if len(m.AppID) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Daemon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Daemon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *InitNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Node != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Node.Size()))
		n19, err := m.Node.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *AddNodeToGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddNodeToGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.NodeID)))
		i += copy(dAtA[i:], m.NodeID)
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.GroupID))
	}
	if m.Suffrage != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Suffrage))
	}
	if m.Bootstrap {
		dAtA[i] = 0x20
		i++
		if m.Bootstrap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CreateDatabaseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDatabaseRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *CreateDatabaseReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDatabaseReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TxCreateTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxCreateTopic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Level))
	}
	if len(m.Roller) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Roller)))
		i += copy(dAtA[i:], m.Roller)
	}
	if len(m.AppID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	return i, nil
}

func (m *TxCreateQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxCreateQueue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.Level))
	}
	if len(m.Roller) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.Roller)))
		i += copy(dAtA[i:], m.Roller)
	}
	if m.Fifo {
		dAtA[i] = 0x28
		i++
		if m.Fifo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxInflight != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MaxInflight))
	}
	if m.MaxVisibility != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MaxVisibility))
	}
	if m.MaxDelay != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MaxDelay))
	}
	if m.MaxRetries != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.MaxRetries))
	}
	if len(m.AppID) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStore(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	return i, nil
}

func (m *TxCreateSegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxCreateSegment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TxRoll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRoll) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RollerID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStore(dAtA, i, uint64(m.RollerID))
	}
	return i, nil
}

func (m *TxDeleteTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxDeleteTopic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TxChangeRing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxChangeRing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.From) > 0 {
		for _, msg := range m.From {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.To) > 0 {
		for _, msg := range m.To {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TxChangeRingCancel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxChangeRingCancel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TxSplitTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxSplitTopic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintStore(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *App) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if len(m.Versions) > 0 {
		for _, s := range m.Versions {
			l = len(s)
			n += 1 + l + sovStore(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovStore(uint64(l))
		}
	}
	return n
}

func (m *Worker) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Memory != 0 {
		n += 1 + sovStore(uint64(m.Memory))
	}
	if m.Cpus != 0 {
		n += 1 + sovStore(uint64(m.Cpus))
	}
	if len(m.Queues) > 0 {
		for _, s := range m.Queues {
			l = len(s)
			n += 1 + l + sovStore(uint64(l))
		}
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.InstanceID)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Cores != 0 {
		n += 1 + sovStore(uint64(m.Cores))
	}
	if m.Memory != 0 {
		n += 1 + sovStore(uint64(m.Memory))
	}
	if m.Bootstrap {
		n += 2
	}
	l = len(m.WebHost)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.ApiHost)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.ApiLoops != 0 {
		n += 1 + sovStore(uint64(m.ApiLoops))
	}
	if m.Member != nil {
		l = m.Member.Size()
		n += 2 + l + sovStore(uint64(l))
	}
	if m.Created != 0 {
		n += 10
	}
	if m.Inited != 0 {
		n += 10
	}
	if m.Changed != 0 {
		n += 10
	}
	if m.Dropped != 0 {
		n += 10
	}
	if m.Removed != 0 {
		n += 10
	}
	if len(m.Drives) > 0 {
		for _, e := range m.Drives {
			l = e.Size()
			n += 2 + l + sovStore(uint64(l))
		}
	}
	l = len(m.Os)
	if l > 0 {
		n += 2 + l + sovStore(uint64(l))
	}
	l = len(m.Arch)
	if l > 0 {
		n += 2 + l + sovStore(uint64(l))
	}
	if m.CpuSpeed != 0 {
		n += 2 + sovStore(uint64(m.CpuSpeed))
	}
	return n
}

func (m *RaftMember) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovStore(uint64(m.Status))
	}
	if m.Membership != 0 {
		n += 1 + sovStore(uint64(m.Membership))
	}
	if m.Suffrage != 0 {
		n += 1 + sovStore(uint64(m.Suffrage))
	}
	if m.Term != 0 {
		n += 1 + sovStore(uint64(m.Term))
	}
	if m.Applied != 0 {
		n += 1 + sovStore(uint64(m.Applied))
	}
	return n
}

func (m *NodeGroup) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovStore(uint64(l))
		}
	}
	if m.Slices != nil {
		l = m.Slices.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *NodeGroup_Member) Size() (n int) {
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Suffrage != 0 {
		n += 1 + sovStore(uint64(m.Suffrage))
	}
	return n
}

func (m *Database) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Created != 0 {
		n += 9
	}
	if m.Changed != 0 {
		n += 9
	}
	if m.Dropped != 0 {
		n += 9
	}
	if m.Removed != 0 {
		n += 9
	}
	if len(m.Slices) > 0 {
		for _, e := range m.Slices {
			l = e.Size()
			n += 1 + l + sovStore(uint64(l))
		}
	}
	return n
}

func (m *SliceID) Size() (n int) {
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovStore(uint64(m.DatabaseID))
	}
	if m.SliceID != 0 {
		n += 1 + sovStore(uint64(m.SliceID))
	}
	return n
}

func (m *Slice) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	if len(m.Slots) > 0 {
		for _, e := range m.Slots {
			l = e.Size()
			n += 1 + l + sovStore(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovStore(uint64(l))
		}
	}
	return n
}

func (m *SliceNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.SliceID != nil {
		l = m.SliceID.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Member != nil {
		l = m.Member.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *Rebalance) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovStore(uint64(m.Timestamp))
	}
	if len(m.Tasks) > 0 {
		for _, e := range m.Tasks {
			l = e.Size()
			n += 1 + l + sovStore(uint64(l))
		}
	}
	return n
}

func (m *Rebalance_Task) Size() (n int) {
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovStore(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovStore(uint64(m.To))
	}
	if m.Low != 0 {
		n += 1 + sovStore(uint64(m.Low))
	}
	if m.Count != 0 {
		n += 1 + sovStore(uint64(m.Count))
	}
	return n
}

func (m *Ring) Size() (n int) {
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovStore(uint64(l))
		}
	}
	return n
}

func (m *SlotRange) Size() (n int) {
	var l int
	_ = l
	if m.Slice != 0 {
		n += 1 + sovStore(uint64(m.Slice))
	}
	if m.Low != 0 {
		n += 1 + sovStore(uint64(m.Low))
	}
	if m.High != 0 {
		n += 1 + sovStore(uint64(m.High))
	}
	return n
}

func (m *Drive) Size() (n int) {
	var l int
	_ = l
	l = len(m.Mount)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovStore(uint64(m.Kind))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Working {
		n += 2
	}
	l = len(m.FileSystem)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *DriveStats) Size() (n int) {
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovStore(uint64(m.Size_))
	}
	if m.Used != 0 {
		n += 1 + sovStore(uint64(m.Used))
	}
	if m.Avail != 0 {
		n += 1 + sovStore(uint64(m.Avail))
	}
	return n
}

func (m *Bucket) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.AccessKey)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.SecretKey)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Api != 0 {
		n += 1 + sovStore(uint64(m.Api))
	}
	return n
}

func (m *RecordID) Size() (n int) {
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovStore(uint64(m.Epoch))
	}
	if m.Seq != 0 {
		n += 1 + sovStore(uint64(m.Seq))
	}
	return n
}

func (m *Record) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Slice != nil {
		l = m.Slice.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *Projection) Size() (n int) {
	var l int
	_ = l
	if m.Codec != 0 {
		n += 1 + sovStore(uint64(m.Codec))
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovStore(uint64(l))
		}
	}
	return n
}

func (m *Projection_Field) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *Index) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Topic) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Slot != 0 {
		n += 1 + sovStore(uint64(m.Slot))
	}
	if m.Type != 0 {
		n += 1 + sovStore(uint64(m.Type))
	}
	if m.QueueID != 0 {
		n += 1 + sozStore(uint64(m.QueueID))
	}
	l = len(m.RollerID)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovStore(uint64(m.Mode))
	}
	if m.WriteSpeed != 0 {
		n += 1 + sovStore(uint64(m.WriteSpeed))
	}
	if m.Codec != 0 {
		n += 1 + sovStore(uint64(m.Codec))
	}
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	if m.SliceKey != nil {
		l = m.SliceKey.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Drive != 0 {
		n += 1 + sovStore(uint64(m.Drive))
	}
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *Roller) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.MinBytes != 0 {
		n += 1 + sovStore(uint64(m.MinBytes))
	}
	if m.MinAge != 0 {
		n += 1 + sovStore(uint64(m.MinAge))
	}
	if m.MinCount != 0 {
		n += 1 + sovStore(uint64(m.MinCount))
	}
	if m.MaxBytes != 0 {
		n += 1 + sovStore(uint64(m.MaxBytes))
	}
	if m.MaxAge != 0 {
		n += 1 + sovStore(uint64(m.MaxAge))
	}
	if m.MaxCount != 0 {
		n += 1 + sovStore(uint64(m.MaxCount))
	}
	return n
}

func (m *Path) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.VolumeID)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.Drive)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Local {
		n += 2
	}
	if m.Bucket {
		n += 2
	}
	return n
}

func (m *Hash) Size() (n int) {
	var l int
	_ = l
	l = len(m.Algorithm)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *Segment) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStore(uint64(m.Id))
	}
	if m.TopicID != 0 {
		n += 1 + sozStore(uint64(m.TopicID))
	}
	if m.Slice != 0 {
		n += 1 + sovStore(uint64(m.Slice))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *SegmentStats) Size() (n int) {
	var l int
	_ = l
	if m.Hash != nil {
		l = m.Hash.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovStore(uint64(m.Count))
	}
	if m.Header != 0 {
		n += 1 + sovStore(uint64(m.Header))
	}
	if m.Body != 0 {
		n += 1 + sovStore(uint64(m.Body))
	}
	if m.Size_ != 0 {
		n += 1 + sovStore(uint64(m.Size_))
	}
	if m.MaxBody != 0 {
		n += 1 + sovStore(uint64(m.MaxBody))
	}
	if m.First != nil {
		l = m.First.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Last != nil {
		l = m.Last.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *SegmentHeader) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovStore(uint64(m.Timestamp))
	}
	if m.TopicID != 0 {
		n += 1 + sozStore(uint64(m.TopicID))
	}
	if m.LogID != 0 {
		n += 1 + sovStore(uint64(m.LogID))
	}
	if m.StartIndex != 0 {
		n += 1 + sovStore(uint64(m.StartIndex))
	}
	return n
}

func (m *GlobalID) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStore(uint64(m.Id))
	}
	if m.Slot != 0 {
		n += 1 + sovStore(uint64(m.Slot))
	}
	if m.RecID != nil {
		l = m.RecID.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *RecordPointer) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	if m.LogID != 0 {
		n += 1 + sovStore(uint64(m.LogID))
	}
	if m.Slot != 0 {
		n += 1 + sovStore(uint64(m.Slot))
	}
	if m.Size_ != 0 {
		n += 1 + sovStore(uint64(m.Size_))
	}
	if m.Pos != 0 {
		n += 1 + sovStore(uint64(m.Pos))
	}
	return n
}

func (m *Queue) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.RequestID != 0 {
		n += 1 + sovStore(uint64(m.RequestID))
	}
	if m.ReplyID != 0 {
		n += 1 + sovStore(uint64(m.ReplyID))
	}
	if m.ErrorID != 0 {
		n += 1 + sovStore(uint64(m.ErrorID))
	}
	if m.Level != 0 {
		n += 1 + sovStore(uint64(m.Level))
	}
	if m.Fifo {
		n += 2
	}
	if m.MaxInflight != 0 {
		n += 1 + sovStore(uint64(m.MaxInflight))
	}
	if m.MaxVisibility != 0 {
		n += 1 + sovStore(uint64(m.MaxVisibility))
	}
	if m.MaxDelay != 0 {
		n += 1 + sovStore(uint64(m.MaxDelay))
	}
	if m.MaxRetries != 0 {
		n += 1 + sovStore(uint64(m.MaxRetries))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 2 + l + sovStore(uint64(l))
		}
	}
	return n
}

func (m *Daemon) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovStore(uint64(m.Level))
	}
	return n
}

func (m *InitNode) Size() (n int) {
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *AddNodeToGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.GroupID != 0 {
		n += 1 + sovStore(uint64(m.GroupID))
	}
	if m.Suffrage != 0 {
		n += 1 + sovStore(uint64(m.Suffrage))
	}
	if m.Bootstrap {
		n += 2
	}
	return n
}

func (m *CreateDatabaseRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *CreateDatabaseReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TxCreateTopic) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovStore(uint64(m.Level))
	}
	l = len(m.Roller)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *TxCreateQueue) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovStore(uint64(m.Level))
	}
	l = len(m.Roller)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.Fifo {
		n += 2
	}
	if m.MaxInflight != 0 {
		n += 1 + sovStore(uint64(m.MaxInflight))
	}
	if m.MaxVisibility != 0 {
		n += 1 + sovStore(uint64(m.MaxVisibility))
	}
	if m.MaxDelay != 0 {
		n += 1 + sovStore(uint64(m.MaxDelay))
	}
	if m.MaxRetries != 0 {
		n += 1 + sovStore(uint64(m.MaxRetries))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	return n
}

func (m *TxCreateSegment) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TxRoll) Size() (n int) {
	var l int
	_ = l
	if m.RollerID != 0 {
		n += 1 + sovStore(uint64(m.RollerID))
	}
	return n
}

func (m *TxDeleteTopic) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TxChangeRing) Size() (n int) {
	var l int
	_ = l
	if len(m.From) > 0 {
		for _, e := range m.From {
			l = e.Size()
			n += 1 + l + sovStore(uint64(l))
		}
	}
	if len(m.To) > 0 {
		for _, e := range m.To {
			l = e.Size()
			n += 1 + l + sovStore(uint64(l))
		}
	}
	return n
}

func (m *TxChangeRingCancel) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TxSplitTopic) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovStore(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStore(x uint64) (n int) {
	return sovStore(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *App) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: App: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: App: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Versions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Versions = append(m.Versions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Worker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Worker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Worker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			m.Cpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queues = append(m.Queues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cores", wireType)
			}
			m.Cores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cores |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bootstrap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bootstrap = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WebHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiLoops", wireType)
			}
			m.ApiLoops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiLoops |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &RaftMember{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 19:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inited", wireType)
			}
			m.Inited = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Inited = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changed", wireType)
			}
			m.Changed = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Changed = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dropped", wireType)
			}
			m.Dropped = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Dropped = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 22:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			m.Removed = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Removed = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drives", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Drives = append(m.Drives, &Drive{})
			if err := m.Drives[len(m.Drives)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Os = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSpeed", wireType)
			}
			m.CpuSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuSpeed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (RaftStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Membership", wireType)
			}
			m.Membership = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Membership |= (Suffrage(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffrage", wireType)
			}
			m.Suffrage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suffrage |= (Suffrage(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applied", wireType)
			}
			m.Applied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applied |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &NodeGroup_Member{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Slices == nil {
				m.Slices = &Slice{}
			}
			if err := m.Slices.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeGroup_Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffrage", wireType)
			}
			m.Suffrage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suffrage |= (Suffrage(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Database) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Database: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Database: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changed", wireType)
			}
			m.Changed = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Changed = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dropped", wireType)
			}
			m.Dropped = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Dropped = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			m.Removed = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Removed = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Slices = append(m.Slices, &Slice{})
			if err := m.Slices[len(m.Slices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SliceID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SliceID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SliceID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliceID", wireType)
			}
			m.SliceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SliceID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Slice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Slice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Slice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &SliceID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slots", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Slots = append(m.Slots, &SlotRange{})
			if err := m.Slots[len(m.Slots)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &SliceNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SliceNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SliceNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SliceNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SliceID == nil {
				m.SliceID = &SliceID{}
			}
			if err := m.SliceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &RaftMember{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rebalance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rebalance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rebalance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, &Rebalance_Task{})
			if err := m.Tasks[len(m.Tasks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rebalance_Task) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			m.Low = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Low |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ring) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ring: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ring: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, &SlotRange{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlotRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlotRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlotRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slice", wireType)
			}
			m.Slice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			m.Low = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Low |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			m.High = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.High |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Drive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Drive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Drive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (Drive_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &DriveStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Working", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Working = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileSystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DriveStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DriveStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DriveStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avail", wireType)
			}
			m.Avail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Avail |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Api", wireType)
			}
			m.Api = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Api |= (Bucket_API(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Record) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Record: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Record: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &Projection{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Slice == nil {
				m.Slice = &Projection{}
			}
			if err := m.Slice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Projection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Projection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Projection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codec", wireType)
			}
			m.Codec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Codec |= (Codec(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Projection_Field) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Field: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Field: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Index) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Index: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Index: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Topic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Topic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Topic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Topic_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueID", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.QueueID = int64(v)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RollerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (Topic_Mode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteSpeed", wireType)
			}
			m.WriteSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteSpeed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codec", wireType)
			}
			m.Codec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Codec |= (Codec(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &Projection{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliceKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SliceKey == nil {
				m.SliceKey = &Projection{}
			}
			if err := m.SliceKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drive", wireType)
			}
			m.Drive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Drive |= (Drive_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Roller) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Roller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Roller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBytes", wireType)
			}
			m.MinBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAge", wireType)
			}
			m.MinAge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAge |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
			}
			m.MinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBytes", wireType)
			}
			m.MaxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			m.MaxAge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAge |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCount", wireType)
			}
			m.MaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Path) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Path: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Path: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drive", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Drive = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Local = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bucket = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Hash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algorithm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Segment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Segment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Segment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.TopicID = int64(v)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slice", wireType)
			}
			m.Slice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &Path{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &SegmentHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SegmentStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegmentStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegmentStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegmentStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hash == nil {
				m.Hash = &Hash{}
			}
			if err := m.Hash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			m.Header = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Header |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			m.Body = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Body |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBody", wireType)
			}
			m.MaxBody = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBody |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.First == nil {
				m.First = &RecordPointer{}
			}
			if err := m.First.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Last == nil {
				m.Last = &RecordPointer{}
			}
			if err := m.Last.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegmentHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegmentHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegmentHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.TopicID = int64(v)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogID", wireType)
			}
			m.LogID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIndex", wireType)
			}
			m.StartIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartIndex |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecID == nil {
				m.RecID = &RecordID{}
			}
			if err := m.RecID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordPointer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordPointer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordPointer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &RecordID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogID", wireType)
			}
			m.LogID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Queue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Queue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Queue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyID", wireType)
			}
			m.ReplyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorID", wireType)
			}
			m.ErrorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (Level(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fifo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fifo = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInflight", wireType)
			}
			m.MaxInflight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInflight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxVisibility", wireType)
			}
			m.MaxVisibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxVisibility |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDelay", wireType)
			}
			m.MaxDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDelay |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
			}
			m.MaxRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetries |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Daemon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Daemon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Daemon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (Level(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &Node{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddNodeToGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddNodeToGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddNodeToGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffrage", wireType)
			}
			m.Suffrage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suffrage |= (Suffrage(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bootstrap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bootstrap = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDatabaseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDatabaseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDatabaseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDatabaseReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDatabaseReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDatabaseReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxCreateTopic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxCreateTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxCreateTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (Level(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxCreateQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxCreateQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxCreateQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (Level(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fifo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fifo = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInflight", wireType)
			}
			m.MaxInflight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInflight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxVisibility", wireType)
			}
			m.MaxVisibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxVisibility |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDelay", wireType)
			}
			m.MaxDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDelay |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
			}
			m.MaxRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetries |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxCreateSegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxCreateSegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxCreateSegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxRoll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxRoll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxRoll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollerID", wireType)
			}
			m.RollerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RollerID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxDeleteTopic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxDeleteTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxDeleteTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxChangeRing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxChangeRing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxChangeRing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From, &Slice{})
			if err := m.From[len(m.From)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To, &Slice{})
			if err := m.To[len(m.To)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxChangeRingCancel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxChangeRingCancel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxChangeRingCancel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxSplitTopic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxSplitTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxSplitTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStore(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStore
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStore
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStore
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStore(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStore = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStore   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proto/store.proto", fileDescriptorStore) }

var fileDescriptorStore = []byte{
	// 2536 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0xcd, 0x72, 0xe3, 0xc6,
	0xf1, 0x17, 0x88, 0x0f, 0x92, 0xad, 0x95, 0x16, 0xc6, 0xca, 0xfb, 0x47, 0x6d, 0xf9, 0xbf, 0x51,
	0x26, 0x76, 0xa2, 0xec, 0xda, 0x5a, 0x47, 0xeb, 0x72, 0x8e, 0x29, 0x8a, 0xe0, 0x6a, 0xe9, 0xd5,
	0x4a, 0xf2, 0x90, 0xb2, 0x5d, 0xa9, 0x54, 0xb9, 0x20, 0x62, 0x44, 0x22, 0x02, 0x39, 0x30, 0x00,
	0xca, 0xa2, 0xab, 0x92, 0x4a, 0x55, 0x5e, 0xc0, 0xc7, 0xe4, 0x90, 0x47, 0xc8, 0x53, 0xe4, 0x92,
	0x43, 0x0e, 0xc9, 0x1b, 0x38, 0x9b, 0xaa, 0x3c, 0x82, 0x8f, 0xa9, 0x54, 0xf7, 0x0c, 0x48, 0x70,
	0xf5, 0xb1, 0xba, 0xe4, 0x36, 0xbf, 0xee, 0x9e, 0xe9, 0x9e, 0xee, 0x9e, 0xee, 0x19, 0x00, 0xde,
	0x4a, 0x33, 0x59, 0xc8, 0x27, 0x79, 0x21, 0x33, 0xb1, 0x4d, 0x63, 0xaf, 0x41, 0xe0, 0xcb, 0xf4,
	0x84, 0x8d, 0xc1, 0x6c, 0xa5, 0xa9, 0xb7, 0x0e, 0xb5, 0x38, 0xf2, 0x8d, 0x4d, 0x63, 0xcb, 0xe2,
	0xb5, 0x38, 0xf2, 0x3c, 0xb0, 0x26, 0xe1, 0x58, 0xf8, 0xb5, 0x4d, 0x63, 0xab, 0xc9, 0x69, 0x8c,
	0xb4, 0x48, 0xe4, 0x03, 0xdf, 0x54, 0x34, 0x1c, 0x7b, 0x0f, 0xa0, 0x71, 0x2e, 0xb2, 0x3c, 0x96,
	0x93, 0xdc, 0x6f, 0x6e, 0x9a, 0x5b, 0x4d, 0x3e, 0xc7, 0x28, 0x5f, 0x84, 0xc3, 0xdc, 0x07, 0xa2,
	0xd3, 0x98, 0x7d, 0x6b, 0x80, 0xf3, 0xb9, 0xcc, 0xce, 0x44, 0x56, 0x51, 0xd9, 0x24, 0x95, 0x3e,
	0xd4, 0xf5, 0x54, 0xad, 0xb5, 0x84, 0xc8, 0x09, 0xa3, 0x28, 0x13, 0x79, 0xae, 0x75, 0x97, 0xd0,
	0xbb, 0x0f, 0xce, 0x58, 0x8c, 0x65, 0x36, 0xf3, 0xed, 0x4d, 0x63, 0xcb, 0xe4, 0x1a, 0xa1, 0xea,
	0x41, 0x3a, 0xcd, 0x7d, 0x67, 0xd3, 0xd8, 0xb2, 0x39, 0x8d, 0x51, 0xf6, 0xab, 0xa9, 0x98, 0x8a,
	0xd2, 0x20, 0x8d, 0xd8, 0x5f, 0x2c, 0xb0, 0x0e, 0x64, 0x24, 0x2e, 0x19, 0xe4, 0x81, 0x35, 0x92,
	0x79, 0x51, 0xfa, 0x00, 0xc7, 0x55, 0x23, 0xcd, 0x65, 0x23, 0x1f, 0x02, 0xc4, 0x93, 0xbc, 0x08,
	0x27, 0x03, 0xd1, 0x0d, 0x7c, 0x8b, 0x98, 0x15, 0x0a, 0xaa, 0xcf, 0xc4, 0x10, 0x27, 0xd6, 0x89,
	0xa7, 0x11, 0x6a, 0xf9, 0x46, 0x4e, 0x84, 0xdf, 0x50, 0x5a, 0x70, 0xec, 0x6d, 0x80, 0x3d, 0x90,
	0x99, 0x40, 0x97, 0x1a, 0x5b, 0x6b, 0x5c, 0x81, 0xca, 0x66, 0x81, 0xe2, 0x54, 0x6e, 0xf6, 0x1d,
	0x68, 0x9e, 0x48, 0x59, 0xe4, 0x45, 0x16, 0xa6, 0xfe, 0xea, 0xa6, 0xb1, 0xd5, 0xe0, 0x0b, 0x02,
	0x5a, 0xfc, 0xb5, 0x38, 0x79, 0x8e, 0x1b, 0xb9, 0xa3, 0x2c, 0xd6, 0x90, 0xdc, 0x9a, 0xc6, 0xc4,
	0x59, 0xd3, 0x6e, 0x55, 0x10, 0xa3, 0x1a, 0xa6, 0xf1, 0xbe, 0x94, 0x69, 0xee, 0xaf, 0x93, 0x09,
	0x73, 0xec, 0xbd, 0x4f, 0x56, 0x9c, 0x88, 0xcc, 0x77, 0x37, 0x8d, 0xad, 0xd5, 0x9d, 0x8d, 0xed,
	0x32, 0x97, 0xb6, 0x79, 0x78, 0x5a, 0xbc, 0x24, 0x1e, 0xd7, 0x32, 0xa8, 0x63, 0x90, 0x89, 0xb0,
	0x10, 0x91, 0xef, 0x6d, 0x1a, 0x5b, 0x0e, 0x2f, 0x21, 0xee, 0x26, 0x9e, 0xc4, 0xc8, 0xb8, 0x47,
	0x0c, 0x8d, 0x68, 0xc6, 0x28, 0x9c, 0x0c, 0x45, 0xe4, 0x6f, 0xe8, 0x19, 0x0a, 0x22, 0x27, 0xca,
	0x64, 0x9a, 0x8a, 0xc8, 0x7f, 0x5b, 0x71, 0x34, 0x44, 0x4e, 0x26, 0xc6, 0xf2, 0x5c, 0x44, 0xfe,
	0x7d, 0xc5, 0xd1, 0xd0, 0xfb, 0x09, 0x38, 0x51, 0x16, 0x9f, 0x8b, 0xdc, 0xf7, 0x37, 0xcd, 0xad,
	0xd5, 0x9d, 0xbb, 0x0b, 0x6b, 0x03, 0xa4, 0x73, 0xcd, 0xc6, 0xe0, 0xcb, 0xdc, 0xdf, 0x51, 0xc1,
	0x97, 0x94, 0xbc, 0x61, 0x36, 0x18, 0xf9, 0x4f, 0x55, 0x58, 0x70, 0x8c, 0x6e, 0x19, 0xa4, 0xd3,
	0x5e, 0x2a, 0x44, 0xe4, 0x7f, 0x44, 0x21, 0x98, 0x63, 0xf6, 0xbd, 0x01, 0xb0, 0xd8, 0xff, 0x55,
	0xc9, 0x5d, 0xa6, 0x70, 0x6d, 0x39, 0x85, 0xdf, 0x07, 0x27, 0x2f, 0xc2, 0x62, 0xaa, 0x72, 0x7b,
	0xfd, 0x75, 0x7f, 0xf6, 0x88, 0xc7, 0xb5, 0x8c, 0xb7, 0x03, 0xa0, 0x3c, 0x9b, 0x8f, 0xe2, 0x94,
	0xb2, 0x6c, 0x7d, 0xc7, 0x5b, 0xcc, 0xe8, 0x4d, 0x4f, 0x4f, 0xb3, 0x70, 0x28, 0x78, 0x45, 0xca,
	0xdb, 0x86, 0x46, 0xae, 0xe9, 0x74, 0x4c, 0xae, 0x9e, 0x31, 0x97, 0xa1, 0x73, 0x2b, 0xb2, 0xb1,
	0xce, 0x32, 0x1a, 0xab, 0x5c, 0x49, 0x93, 0x58, 0x44, 0x94, 0x61, 0x16, 0x2f, 0x21, 0xfb, 0xce,
	0x80, 0x26, 0x1e, 0x9f, 0xbd, 0x4c, 0x4e, 0xab, 0x75, 0xc4, 0xbc, 0xb6, 0x8e, 0x7c, 0x04, 0x75,
	0x6d, 0x9d, 0x6f, 0x52, 0x50, 0x1e, 0x2c, 0xcc, 0x99, 0xaf, 0xb4, 0xad, 0x13, 0xa9, 0x14, 0xc5,
	0x48, 0xe6, 0x49, 0x3c, 0xa0, 0xe3, 0x6b, 0x2c, 0x47, 0xb2, 0x87, 0x74, 0xae, 0xd9, 0x0f, 0x8e,
	0xc0, 0xd1, 0x41, 0xb8, 0x0f, 0xce, 0x44, 0x46, 0x78, 0x1c, 0x55, 0x20, 0x34, 0x5a, 0x72, 0x48,
	0xed, 0xcd, 0x0e, 0x61, 0xff, 0x34, 0xa0, 0x11, 0x84, 0x45, 0x78, 0x12, 0xe6, 0xd5, 0x2a, 0x61,
	0x5f, 0xbb, 0xc3, 0x4d, 0x58, 0xc5, 0xea, 0x98, 0xc5, 0x69, 0xb1, 0xa8, 0x14, 0x55, 0x52, 0xf5,
	0x5c, 0x58, 0xcb, 0xe7, 0xa2, 0x92, 0xff, 0xf6, 0xb5, 0xf9, 0xef, 0x5c, 0x9b, 0xff, 0xf5, 0x4b,
	0xf9, 0x3f, 0xf7, 0x9a, 0x79, 0x83, 0xd7, 0x58, 0x1b, 0xea, 0x44, 0xe8, 0x06, 0x58, 0xc9, 0x22,
	0xbd, 0x5b, 0xed, 0x3a, 0x9b, 0x57, 0x28, 0xa8, 0x2d, 0x57, 0xa2, 0xb4, 0x69, 0x9b, 0x97, 0x90,
	0xfd, 0xce, 0x00, 0x9b, 0x56, 0xf1, 0x7e, 0x38, 0xf7, 0xd2, 0xea, 0xce, 0x5b, 0xaf, 0xe9, 0xec,
	0x06, 0xe4, 0xb8, 0x9f, 0x82, 0x9d, 0x27, 0xb2, 0xc0, 0x03, 0x81, 0x96, 0xdd, 0xab, 0x4a, 0xc9,
	0x82, 0xe3, 0x9e, 0xb9, 0x92, 0x40, 0x51, 0x0c, 0x5d, 0x99, 0x2f, 0xf7, 0x5e, 0x5b, 0x10, 0x93,
	0x86, 0x2b, 0x09, 0xf6, 0x5b, 0x68, 0xce, 0x69, 0xd7, 0x26, 0xc0, 0xe3, 0xe5, 0x1d, 0x5c, 0x69,
	0x62, 0x29, 0x51, 0x29, 0x78, 0xe6, 0x9b, 0x0b, 0x1e, 0xfb, 0xb3, 0x01, 0x4d, 0x2e, 0x4e, 0xc2,
	0x04, 0xcb, 0x3e, 0x96, 0xe6, 0x22, 0x1e, 0x8b, 0xbc, 0x08, 0xc7, 0xa9, 0x3e, 0x15, 0x0b, 0x82,
	0xb7, 0x0d, 0x76, 0x11, 0xe6, 0x67, 0xa5, 0x07, 0xfc, 0xca, 0xc2, 0xe5, 0x0a, 0xdb, 0xfd, 0x30,
	0x3f, 0xe3, 0x4a, 0xec, 0x01, 0x07, 0x0b, 0x21, 0xa6, 0xdc, 0x69, 0x26, 0xc7, 0x3a, 0x34, 0x34,
	0xc6, 0xb4, 0x2c, 0xa4, 0x8e, 0x47, 0xad, 0x90, 0x9e, 0x0b, 0x66, 0x22, 0xbf, 0x26, 0x93, 0x6d,
	0x8e, 0x43, 0xd5, 0x54, 0xa6, 0x93, 0x82, 0x12, 0xce, 0xe6, 0x0a, 0xb0, 0xa7, 0x60, 0xf1, 0x78,
	0x32, 0xf4, 0x1e, 0x83, 0x93, 0xa1, 0xcb, 0x6f, 0x0c, 0x87, 0x16, 0x61, 0x7b, 0xe8, 0x64, 0x4d,
	0xc4, 0x75, 0xc9, 0x55, 0xda, 0x1c, 0x05, 0x4a, 0xfd, 0xb5, 0x85, 0x7e, 0x6c, 0xa7, 0xf1, 0x70,
	0xa4, 0x4d, 0xa2, 0x31, 0xfb, 0x87, 0x01, 0x36, 0xd5, 0x61, 0x5c, 0x65, 0x4c, 0xd6, 0xa9, 0x48,
	0x29, 0xe0, 0x6d, 0x81, 0x75, 0x16, 0x4f, 0x22, 0x7d, 0x4a, 0x37, 0x5e, 0x2b, 0xde, 0xdb, 0x2f,
	0xe2, 0x49, 0xc4, 0x49, 0xc2, 0x7b, 0x04, 0x36, 0x96, 0xc8, 0xfc, 0x72, 0x90, 0x48, 0x14, 0xcb,
	0x68, 0xce, 0x95, 0x08, 0xb5, 0x44, 0x99, 0x9d, 0xc5, 0x93, 0x21, 0xf9, 0xa2, 0xc1, 0x4b, 0x88,
	0xa9, 0x7f, 0x1a, 0x27, 0xa2, 0x37, 0xcb, 0x0b, 0x31, 0xa6, 0xf3, 0xd7, 0xe4, 0x15, 0x0a, 0x63,
	0x60, 0xa1, 0x4e, 0xaf, 0x0e, 0xe6, 0xf3, 0x20, 0x70, 0x57, 0x70, 0xd0, 0xeb, 0x05, 0xae, 0xe1,
	0x35, 0xc0, 0x3a, 0xf8, 0xec, 0x65, 0xc7, 0xad, 0xb1, 0x4f, 0x00, 0x16, 0x2a, 0x71, 0xd7, 0x79,
	0xfc, 0x8d, 0xd0, 0x57, 0x2b, 0x1a, 0x23, 0x6d, 0x9a, 0x0b, 0xb5, 0x2b, 0x8b, 0xd3, 0x18, 0xf7,
	0x1f, 0x9e, 0x87, 0x71, 0x42, 0xf6, 0x5b, 0x5c, 0x01, 0xf6, 0x27, 0x03, 0x9c, 0xdd, 0xe9, 0xe0,
	0x4c, 0x14, 0x97, 0x3a, 0xca, 0x3b, 0xd0, 0x0c, 0x07, 0x03, 0x91, 0xe7, 0x2f, 0xc4, 0x4c, 0x17,
	0x9f, 0x05, 0x01, 0xb9, 0xb9, 0x18, 0x64, 0xa2, 0x40, 0xae, 0xaa, 0x3f, 0x0b, 0x02, 0x06, 0x67,
	0x9a, 0x25, 0xfa, 0x92, 0x82, 0x43, 0xef, 0xc7, 0x60, 0x86, 0x69, 0xac, 0xdb, 0x43, 0xc5, 0x79,
	0x4a, 0xf9, 0x76, 0xeb, 0xa8, 0xcb, 0x51, 0x80, 0xad, 0x81, 0xd9, 0x3a, 0xea, 0x7a, 0x0e, 0xd4,
	0x7a, 0x4f, 0xdd, 0x15, 0xb6, 0x03, 0x0d, 0x2e, 0x06, 0x32, 0x8b, 0xba, 0x01, 0xee, 0x40, 0xa4,
	0x72, 0x30, 0xd2, 0x5b, 0x55, 0x00, 0x55, 0xe5, 0xe2, 0x2b, 0xbd, 0x55, 0x1c, 0xb2, 0x5f, 0x81,
	0xa3, 0xe6, 0xa0, 0xd2, 0x33, 0x31, 0xd3, 0x55, 0xa2, 0xa2, 0xf4, 0x28, 0x93, 0xbf, 0x16, 0x03,
	0xac, 0x93, 0x1c, 0x05, 0x28, 0xb6, 0x94, 0x61, 0xb5, 0x1b, 0x24, 0x95, 0x08, 0x3b, 0x07, 0x58,
	0x10, 0xbd, 0xf7, 0x30, 0xe7, 0x23, 0x31, 0x20, 0x1d, 0xeb, 0xd5, 0xea, 0xd7, 0x46, 0x32, 0x57,
	0x5c, 0x34, 0x1d, 0xeb, 0xb6, 0xca, 0xfd, 0x26, 0x57, 0xe0, 0xc1, 0x63, 0xb0, 0x9f, 0xc5, 0x22,
	0x89, 0x6e, 0x53, 0xf2, 0xd9, 0x2f, 0xc0, 0xee, 0x4e, 0x22, 0x71, 0xc1, 0x3e, 0x06, 0xab, 0x3f,
	0x4b, 0x85, 0xd7, 0x04, 0x7b, 0xb7, 0xcf, 0x3b, 0x1d, 0x77, 0xc5, 0x03, 0x70, 0x8e, 0x78, 0xe7,
	0x59, 0xf7, 0x0b, 0xb7, 0x86, 0x64, 0x4e, 0x64, 0xd3, 0xbb, 0x03, 0x8d, 0x67, 0xc7, 0xfb, 0xfb,
	0xfd, 0xce, 0x17, 0x7d, 0xd7, 0x60, 0xdf, 0x9b, 0x60, 0xf7, 0x65, 0x1a, 0x0f, 0x6e, 0xd5, 0x43,
	0x31, 0xad, 0x12, 0x59, 0x50, 0x68, 0xd7, 0x38, 0x8d, 0xf1, 0xb0, 0x14, 0xb3, 0x54, 0xe8, 0x5b,
	0x41, 0xc5, 0x4b, 0xb4, 0xec, 0x36, 0x5a, 0xc5, 0x49, 0x02, 0x0f, 0x00, 0x5d, 0x7e, 0xbb, 0x01,
	0x45, 0xdc, 0xe3, 0x25, 0xc4, 0x2b, 0x4e, 0x26, 0x93, 0x44, 0x64, 0xdd, 0x80, 0x9a, 0x4c, 0x93,
	0xcf, 0x31, 0xae, 0x3f, 0x96, 0x91, 0xa0, 0x16, 0x73, 0xc5, 0xfa, 0x2f, 0xb1, 0x0a, 0x93, 0x04,
	0x1e, 0xa3, 0xaf, 0xb3, 0xb8, 0x10, 0xea, 0xaa, 0xd4, 0x50, 0x1d, 0x64, 0x41, 0x59, 0x84, 0xa5,
	0x79, 0x63, 0x58, 0x74, 0x7e, 0xc0, 0x9b, 0xf2, 0xe3, 0x43, 0x68, 0x50, 0xf0, 0x31, 0xd7, 0x57,
	0x6f, 0x10, 0x9e, 0x4b, 0x61, 0x46, 0xd1, 0xbd, 0x8f, 0xae, 0xc4, 0xd7, 0x15, 0x16, 0x25, 0x82,
	0x4d, 0x24, 0x1f, 0x8c, 0xc4, 0x38, 0xf4, 0xef, 0xaa, 0x26, 0xa2, 0x10, 0xdb, 0xd0, 0x81, 0xbe,
	0x03, 0x8d, 0x5e, 0xbf, 0x75, 0x10, 0xb4, 0x78, 0xe0, 0xae, 0xb0, 0x0f, 0xc1, 0x42, 0x47, 0x60,
	0x61, 0xd8, 0x3f, 0xdc, 0x73, 0x57, 0x30, 0xe0, 0x9f, 0x1e, 0x77, 0x8e, 0x3b, 0xae, 0x81, 0xc3,
	0x7e, 0x6b, 0x77, 0xbf, 0xa3, 0xd2, 0xa0, 0xdd, 0x6a, 0x3f, 0xef, 0xb8, 0x26, 0xfb, 0x9b, 0x01,
	0x0e, 0x27, 0x1f, 0xdf, 0xea, 0x15, 0xf6, 0x00, 0x1a, 0xe3, 0x78, 0xb2, 0x3b, 0x2b, 0x44, 0xae,
	0x6b, 0xc5, 0x1c, 0xd3, 0x0b, 0x21, 0x9e, 0xb4, 0x86, 0x2a, 0x07, 0xf0, 0x85, 0x40, 0x48, 0xcf,
	0x69, 0x53, 0x7d, 0xb5, 0xe7, 0x73, 0x08, 0x13, 0x2f, 0xbc, 0x50, 0xeb, 0x39, 0x9a, 0xa7, 0x31,
	0xad, 0x17, 0x5e, 0xe0, 0x7a, 0x75, 0xbd, 0x1e, 0x21, 0x3d, 0x47, 0xad, 0xd7, 0x98, 0xcf, 0x21,
	0xcc, 0xfe, 0x68, 0x80, 0x75, 0x14, 0x16, 0xa3, 0xb9, 0xf1, 0xc6, 0xb2, 0xf1, 0xe7, 0x32, 0x99,
	0x8e, 0xcb, 0xce, 0x8b, 0xcf, 0x45, 0x8d, 0xf1, 0x10, 0xaa, 0x98, 0xa8, 0x72, 0xa5, 0xbd, 0xbf,
	0x01, 0x76, 0x22, 0x07, 0x61, 0xa2, 0x2b, 0xb5, 0x02, 0x68, 0xd8, 0x09, 0x55, 0x26, 0xda, 0x4e,
	0x83, 0x6b, 0xc4, 0xfe, 0x7f, 0x71, 0xf8, 0xf6, 0x51, 0x50, 0x1d, 0x3e, 0x55, 0xc4, 0x5c, 0x83,
	0x71, 0xb0, 0x9e, 0x87, 0xf9, 0x88, 0x6a, 0x67, 0x32, 0x94, 0x59, 0x5c, 0x8c, 0xc6, 0xda, 0xbe,
	0x05, 0x01, 0x55, 0x9e, 0x87, 0xc9, 0x54, 0xb9, 0xfd, 0x0e, 0x57, 0x80, 0xdd, 0x87, 0x66, 0x6b,
	0x2e, 0x82, 0xe1, 0xe3, 0xed, 0xa7, 0x3b, 0xee, 0x0a, 0x86, 0xaf, 0xde, 0x13, 0xc3, 0xb1, 0x98,
	0x14, 0x97, 0xe2, 0xe7, 0x43, 0xbd, 0xc0, 0xb3, 0xa1, 0x77, 0xeb, 0xf1, 0x12, 0x2e, 0x9a, 0xa6,
	0x59, 0x6d, 0x9a, 0x0c, 0xac, 0x34, 0x2c, 0x46, 0xb4, 0xd7, 0xd5, 0x9d, 0xf5, 0x4a, 0x12, 0x87,
	0xc5, 0x88, 0x13, 0xcf, 0x7b, 0x02, 0xce, 0x48, 0x84, 0x91, 0xc8, 0x68, 0xeb, 0xab, 0x3b, 0xff,
	0x57, 0x69, 0xd4, 0xca, 0x8c, 0xe7, 0xc4, 0xe6, 0x5a, 0xcc, 0x7b, 0xbf, 0xec, 0x8c, 0x0e, 0xc9,
	0xdf, 0xbf, 0x24, 0x5f, 0xed, 0x8d, 0xec, 0x3f, 0x06, 0xdc, 0xa9, 0xd2, 0xd1, 0xa6, 0x51, 0x98,
	0x8f, 0x74, 0x95, 0xae, 0xd8, 0x84, 0x9e, 0xe4, 0xc4, 0x5b, 0x5c, 0x2d, 0x54, 0x99, 0x57, 0x00,
	0x83, 0xa4, 0x2d, 0x55, 0x79, 0x5a, 0x1a, 0xe4, 0x81, 0x75, 0x22, 0xa3, 0x99, 0xce, 0x51, 0x1a,
	0xcf, 0xdb, 0xa4, 0x7a, 0xc6, 0xab, 0x36, 0xe9, 0x43, 0x1d, 0x33, 0x11, 0x45, 0x1d, 0x2a, 0x73,
	0x25, 0xf4, 0x3e, 0x00, 0xfb, 0x34, 0xce, 0xf2, 0x82, 0xd2, 0x72, 0xc9, 0x05, 0xaa, 0xb3, 0x1c,
	0xc9, 0x78, 0x52, 0x88, 0x8c, 0x2b, 0x29, 0xef, 0x31, 0x58, 0x49, 0x98, 0xab, 0x54, 0xbd, 0x41,
	0x9a, 0x84, 0xd8, 0x6f, 0x60, 0x6d, 0xc9, 0x8f, 0x97, 0xef, 0x70, 0x56, 0xf5, 0x0e, 0x77, 0x63,
	0x88, 0x13, 0x39, 0xec, 0x06, 0x65, 0x47, 0x27, 0x80, 0xa5, 0x31, 0x2f, 0xc2, 0xac, 0xa0, 0x66,
	0x41, 0x2e, 0x30, 0x79, 0x85, 0xc2, 0xbe, 0x80, 0xc6, 0x5e, 0x22, 0x4f, 0xc2, 0xa4, 0x1b, 0x5c,
	0xd5, 0x08, 0xa8, 0xe8, 0xab, 0x4b, 0x55, 0x59, 0xf4, 0xed, 0x4c, 0x0c, 0xb4, 0x96, 0xd5, 0xea,
	0x43, 0xa6, 0x6c, 0xcc, 0x5c, 0x09, 0xb0, 0xdf, 0x1b, 0xb0, 0xb6, 0xb4, 0x61, 0x8f, 0x55, 0x2e,
	0xe9, 0x57, 0x4d, 0x44, 0x9d, 0xf3, 0x5d, 0xd4, 0xaa, 0xbb, 0xb8, 0xaa, 0xfd, 0x94, 0x21, 0xb4,
	0x34, 0x0d, 0x43, 0xe8, 0x82, 0x99, 0xca, 0x5c, 0x47, 0x15, 0x87, 0xec, 0xdf, 0x35, 0xb0, 0x3f,
	0xc5, 0x66, 0x73, 0xab, 0x62, 0xf7, 0x0e, 0x34, 0x33, 0xf1, 0xd5, 0x54, 0xe4, 0xc5, 0xdc, 0x8f,
	0x0b, 0x82, 0x7a, 0xf6, 0xa4, 0xc9, 0x4c, 0x7f, 0x6f, 0xb1, 0x78, 0x09, 0x91, 0x23, 0xb2, 0x4c,
	0x66, 0xba, 0xc1, 0x59, 0xbc, 0x84, 0xd8, 0x7a, 0x12, 0x71, 0x2e, 0x12, 0x4a, 0xa9, 0xa5, 0xd6,
	0xb3, 0x8f, 0x64, 0xae, 0xb8, 0x74, 0xc5, 0x8e, 0x4f, 0x25, 0xf5, 0x9e, 0x06, 0xa7, 0x31, 0xbe,
	0xea, 0xc6, 0xe1, 0x45, 0x77, 0x72, 0x9a, 0xc4, 0xc3, 0x51, 0xa1, 0xdf, 0xc1, 0x55, 0x92, 0xf7,
	0x2e, 0xac, 0x8d, 0xc3, 0x8b, 0xcf, 0xe2, 0x3c, 0x3e, 0x89, 0x93, 0xb8, 0x98, 0x51, 0x7b, 0xb1,
	0xf8, 0x32, 0x51, 0x57, 0xcf, 0x40, 0x24, 0xe1, 0x8c, 0x3e, 0xbc, 0xa8, 0xea, 0x49, 0x18, 0xd3,
	0x63, 0x1c, 0x5e, 0x70, 0x51, 0x64, 0xb1, 0x28, 0xbf, 0xbd, 0x54, 0x28, 0x74, 0x4d, 0x4c, 0xd3,
	0x6e, 0xa0, 0x7b, 0x91, 0x02, 0xf3, 0x2f, 0x6d, 0x6e, 0xe5, 0x4b, 0x5b, 0x0f, 0x9c, 0x20, 0x14,
	0x63, 0x39, 0xb9, 0x95, 0xa3, 0xe7, 0x6e, 0x31, 0x6f, 0x72, 0x0b, 0xdb, 0x86, 0x46, 0x77, 0x12,
	0x17, 0xf4, 0xb8, 0x62, 0x60, 0xe1, 0x73, 0xea, 0x72, 0x61, 0xa0, 0xe7, 0x18, 0xf1, 0xd8, 0xb7,
	0x06, 0xac, 0xb7, 0xa2, 0x08, 0x29, 0x7d, 0xa9, 0xbe, 0x10, 0x5c, 0xf7, 0x26, 0xf3, 0xa1, 0x3e,
	0x44, 0x01, 0x9d, 0x6a, 0x26, 0x2f, 0xe1, 0xd2, 0x73, 0xdd, 0xbc, 0xc5, 0xf7, 0x8b, 0xa5, 0xef,
	0x61, 0xd6, 0x6b, 0xdf, 0xc3, 0xd8, 0x63, 0x78, 0xbb, 0x4d, 0x4f, 0xed, 0xf2, 0x45, 0xcf, 0x55,
	0x3e, 0x5d, 0xd5, 0xaf, 0xd8, 0xdb, 0x70, 0xef, 0x75, 0xe1, 0x34, 0x99, 0xb1, 0x0b, 0x58, 0xeb,
	0x5f, 0x28, 0x86, 0xba, 0xb2, 0x5d, 0xd5, 0xeb, 0xe6, 0x2e, 0xad, 0xdd, 0x98, 0x69, 0xf7, 0xc1,
	0x51, 0x37, 0x2c, 0xdd, 0xf7, 0x34, 0x5a, 0x44, 0xda, 0xaa, 0x44, 0x9a, 0x7d, 0x5b, 0x5b, 0xa8,
	0x56, 0xc7, 0xe8, 0x7f, 0xa0, 0xba, 0x4c, 0x7e, 0xfb, 0xfa, 0xe4, 0x77, 0x6e, 0x91, 0xfc, 0xf5,
	0x37, 0x25, 0x7f, 0xe3, 0xc6, 0xe4, 0x6f, 0x5e, 0x9f, 0xfc, 0x50, 0x75, 0xc9, 0x5b, 0x70, 0xb7,
	0xf4, 0x88, 0x2e, 0xdc, 0xec, 0x5d, 0x70, 0xfa, 0x17, 0x78, 0xa7, 0x5a, 0xba, 0xcf, 0xaa, 0x42,
	0x3a, 0xc7, 0xec, 0x2e, 0xba, 0x32, 0x10, 0x89, 0xd0, 0x51, 0x64, 0x7d, 0xb8, 0xd3, 0xbf, 0x68,
	0xd3, 0xd7, 0x16, 0x7a, 0x13, 0xff, 0x68, 0xfe, 0xce, 0xbe, 0xf2, 0xd3, 0x89, 0x7a, 0x78, 0xff,
	0x40, 0x3f, 0xbc, 0xaf, 0x14, 0xa9, 0x15, 0x92, 0x6d, 0x80, 0x57, 0x5d, 0xb5, 0x8d, 0xcf, 0xfa,
	0x84, 0xad, 0xa3, 0xae, 0x5e, 0x9a, 0xc4, 0x05, 0xe9, 0x7e, 0xb4, 0x03, 0x36, 0xc5, 0xc6, 0x5b,
	0x85, 0xfa, 0xcb, 0x6e, 0xaf, 0xd7, 0x3d, 0x3c, 0x70, 0x57, 0xf0, 0x6e, 0xb9, 0x7b, 0xdc, 0xeb,
	0x1e, 0x74, 0x7a, 0x3d, 0xd7, 0xf0, 0xd6, 0x01, 0x76, 0x5b, 0xed, 0x17, 0x7b, 0xfc, 0xf0, 0xf8,
	0x20, 0x70, 0x6b, 0x8f, 0x3e, 0x06, 0x9b, 0xee, 0xcb, 0xf8, 0xf8, 0xfc, 0xa4, 0x57, 0x4e, 0x38,
	0xe2, 0x87, 0xfd, 0xc3, 0xdd, 0xe3, 0x67, 0xae, 0x41, 0x6b, 0xf5, 0xf6, 0x8e, 0x5a, 0xed, 0x17,
	0x6e, 0x0d, 0x85, 0xda, 0xbb, 0x87, 0xdc, 0x35, 0x1f, 0xfd, 0x0c, 0x1a, 0xe5, 0xb1, 0xc1, 0x9b,
	0xcc, 0x67, 0x87, 0xfd, 0x0e, 0x77, 0x57, 0xbc, 0x35, 0x68, 0x1e, 0x1c, 0x1e, 0x7c, 0xa9, 0x20,
	0x4d, 0xee, 0xf5, 0x5b, 0x7b, 0xdd, 0x83, 0x3d, 0xb7, 0xf6, 0xa8, 0xad, 0xbe, 0x6e, 0xaa, 0xaf,
	0x91, 0xf4, 0x72, 0x39, 0xdc, 0xdf, 0x3f, 0xfc, 0xbc, 0x9c, 0xd7, 0x6e, 0x1d, 0x04, 0xdd, 0xa0,
	0xd5, 0xc7, 0x5b, 0x2e, 0x80, 0xb3, 0xdf, 0x69, 0x05, 0x1d, 0xee, 0xd6, 0xe8, 0x6e, 0xfc, 0xfc,
	0xb8, 0x1f, 0x1c, 0x7e, 0x7e, 0xe0, 0x9a, 0xbb, 0x3f, 0xff, 0xeb, 0xab, 0x87, 0xc6, 0xdf, 0x5f,
	0x3d, 0x34, 0xbe, 0x7b, 0xf5, 0xd0, 0xf8, 0xc3, 0xbf, 0x1e, 0xae, 0xfc, 0xf2, 0xbd, 0x61, 0x5c,
	0x8c, 0xa6, 0x27, 0xdb, 0x03, 0x39, 0x7e, 0x42, 0x57, 0xa0, 0x0f, 0xa2, 0x27, 0x43, 0x31, 0xf9,
	0x26, 0x8c, 0x9f, 0x54, 0x7e, 0x5a, 0x9c, 0x38, 0x04, 0x9e, 0xfe, 0x37, 0x00, 0x00, 0xff, 0xff,
	0x94, 0x80, 0xc7, 0x19, 0xca, 0x18, 0x00, 0x00,
}
